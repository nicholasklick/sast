//! Interprocedural Taint Analysis - Track taint across function boundaries
//!
//! This module extends the intraprocedural taint analysis to track taint
//! through function calls using the call graph.
//!
//! ## Constant Propagation for Precision
//!
//! This module integrates symbolic execution for constant propagation to
//! eliminate false positives from infeasible branches. For example:
//!
//! ```java
//! int num = 106;
//! String bar = (7 * 18) + num > 200 ? "safe" : taintedParam;
//! // Since 126 + 106 = 232 > 200 is ALWAYS TRUE, bar = "safe"
//! sink(bar);  // NOT a vulnerability
//! ```

use crate::call_graph::CallGraph;
use crate::flow_summary::FlowSummaryRegistry;
use crate::language_handler::{LanguageTaintHandler, SafeSinkPattern, get_handler_for_language, evaluate_node_symbolic};
use crate::symbolic::{SymbolicValue, SymbolicState, BinaryOperator, UnaryOperator};
use crate::taint::{TaintAnalysisResult, TaintSink, TaintSource, TaintSourceKind, TaintValue, TaintVulnerability, Severity, TaintSinkKind, FlowState};
use crate::taint_config::get_yaml_sanitizer_flow_states;
use gittera_parser::ast::{AstNode, AstNodeKind, LiteralValue};
use gittera_parser::language::Language;
use std::collections::{HashMap, HashSet};

/// Summary of taint behavior for a function
#[derive(Debug, Clone)]
pub struct FunctionTaintSummary {
    /// Function name
    pub name: String,
    /// Which parameters are tainted in the summary
    pub tainted_params: HashSet<usize>,
    /// Whether the return value is tainted
    pub returns_taint: bool,
    /// What sanitization this function performs
    pub sanitizes_params: HashSet<usize>,
    /// Sources generated by this function
    pub generates_taint: bool,
}

impl FunctionTaintSummary {
    pub fn new(name: String) -> Self {
        Self {
            name,
            tainted_params: HashSet::new(),
            returns_taint: false,
            sanitizes_params: HashSet::new(),
            generates_taint: false,
        }
    }
}

/// Interprocedural taint analysis engine
pub struct InterproceduralTaintAnalysis {
    sources: Vec<TaintSource>,
    sinks: Vec<TaintSink>,
    sanitizers: HashSet<String>,
    /// Function summaries computed during analysis
    summaries: HashMap<String, FunctionTaintSummary>,
    /// Flow summary registry for library functions
    flow_registry: FlowSummaryRegistry,
    /// Cache of method definitions indexed by method name for inter-procedural analysis
    method_cache: HashMap<String, AstNode>,
    /// Language-specific handler for AST and taint patterns
    language_handler: Box<dyn LanguageTaintHandler>,
}

impl InterproceduralTaintAnalysis {
    /// Create a new analysis engine with default (Java) language handler
    pub fn new() -> Self {
        Self::new_with_language(Language::Java)
    }

    /// Create a new analysis engine with a specific language handler
    pub fn new_with_language(language: Language) -> Self {
        Self {
            sources: Vec::new(),
            sinks: Vec::new(),
            sanitizers: HashSet::new(),
            summaries: HashMap::new(),
            flow_registry: FlowSummaryRegistry::java_stdlib(),
            method_cache: HashMap::new(),
            language_handler: get_handler_for_language(language),
        }
    }

    /// Build a cache of method definitions from the AST for inter-procedural analysis
    fn build_method_cache(&mut self, ast: &AstNode) {
        self.method_cache.clear();
        self.collect_methods(ast);
    }

    fn collect_methods(&mut self, node: &AstNode) {
        match &node.kind {
            AstNodeKind::MethodDeclaration { name, .. } |
            AstNodeKind::FunctionDeclaration { name, .. } => {
                // Store the method by its name
                self.method_cache.insert(name.clone(), node.clone());
            }
            _ => {}
        }
        for child in &node.children {
            self.collect_methods(child);
        }
    }

    pub fn add_source(&mut self, source: TaintSource) {
        self.sources.push(source);
    }

    pub fn add_sink(&mut self, sink: TaintSink) {
        self.sinks.push(sink);
    }

    pub fn add_sanitizer(&mut self, name: String) {
        self.sanitizers.insert(name);
    }

    /// Analyze the program with interprocedural taint tracking
    pub fn analyze(
        &mut self,
        ast: &AstNode,
        call_graph: &CallGraph,
    ) -> TaintAnalysisResult {
        // Phase 1: Build function summaries in topological order (bottom-up)
        self.build_summaries(call_graph, ast);

        // Phase 2: Find vulnerabilities using summaries
        self.find_vulnerabilities_interprocedural(ast, call_graph)
    }

    /// Build function summaries in bottom-up order
    fn build_summaries(
        &mut self,
        call_graph: &CallGraph,
        ast: &AstNode,
    ) {
        // Get topological order (callees before callers)
        let order = match call_graph.topological_sort() {
            Some(order) => order,
            None => {
                // Cycle detected - fall back to arbitrary order
                call_graph.nodes().map(|n| n.name.clone()).collect()
            }
        };

        // Process functions in order
        for func_name in order {
            let summary = self.compute_summary(&func_name, ast, call_graph);
            self.summaries.insert(func_name, summary);
        }
    }

    /// Compute taint summary for a single function
    fn compute_summary(
        &self,
        func_name: &str,
        ast: &AstNode,
        call_graph: &CallGraph,
    ) -> FunctionTaintSummary {
        let mut summary = FunctionTaintSummary::new(func_name.to_string());

        // Find the function AST node
        let func_node = self.find_function_node(ast, func_name);
        if func_node.is_none() {
            return summary;
        }

        // Check if this function is a source
        if self.is_source_function(func_name) {
            summary.generates_taint = true;
            summary.returns_taint = true;
            return summary;
        }

        // Check if this function is a sanitizer
        if self.is_sanitizer_function(func_name) {
            summary.sanitizes_params.insert(0); // Sanitizes first parameter
            return summary;
        }

        // Analyze function body for taint flow
        if let Some(func) = func_node {
            self.analyze_function_body(func, &mut summary, call_graph);
        }

        summary
    }

    /// Analyze a function body to determine taint behavior
    fn analyze_function_body(
        &self,
        func: &AstNode,
        summary: &mut FunctionTaintSummary,
        call_graph: &CallGraph,
    ) {
        // Extract parameters
        let params = self.extract_parameters(func);

        // Look for:
        // 1. Calls to sources -> generates_taint = true, returns_taint = true
        // 2. Return statements with parameters -> mark those params as contributing to return
        // 3. Calls to other functions -> use their summaries

        self.visit_for_taint_behavior(func, summary, &params, call_graph);
    }

    /// Visit nodes to determine taint behavior
    fn visit_for_taint_behavior(
        &self,
        node: &AstNode,
        summary: &mut FunctionTaintSummary,
        params: &[String],
        call_graph: &CallGraph,
    ) {
        match &node.kind {
            AstNodeKind::CallExpression { callee, .. } => {
                // Check if calling a source
                if self.is_source_function(callee) {
                    summary.generates_taint = true;
                    // If this call result might be returned, mark returns_taint
                    // For now, conservatively assume it might be
                    summary.returns_taint = true;
                } else if let Some(callee_summary) = self.summaries.get(callee) {
                    // Use summary of called function
                    if callee_summary.returns_taint {
                        summary.returns_taint = true;
                    }
                    if callee_summary.generates_taint {
                        summary.generates_taint = true;
                    }
                }
            }

            AstNodeKind::ReturnStatement => {
                // Check if returning a parameter or tainted value
                // For simplicity, check if any identifier in return is a parameter
                for child in &node.children {
                    if let Some(name) = self.extract_identifier(child) {
                        if let Some(param_idx) = params.iter().position(|p| p == &name) {
                            summary.tainted_params.insert(param_idx);
                            summary.returns_taint = true;
                        }
                    }
                }
            }

            _ => {}
        }

        // Recursively visit children
        for child in &node.children {
            self.visit_for_taint_behavior(child, summary, params, call_graph);
        }
    }

    /// Find vulnerabilities using interprocedural analysis
    fn find_vulnerabilities_interprocedural(
        &mut self,
        ast: &AstNode,
        _call_graph: &CallGraph,
    ) -> TaintAnalysisResult {
        // Build method cache for inter-procedural analysis of helper methods
        self.build_method_cache(ast);

        let mut vulnerabilities = Vec::new();

        // Track taint through the program using summaries
        let mut tainted_vars: HashSet<String> = HashSet::new();

        // Initialize symbolic state for constant propagation
        let mut sym_state = SymbolicState::new();

        // Track list sizes for precise index-based taint tracking
        let mut list_sizes: HashMap<String, usize> = HashMap::new();

        // Track variables that have been validated for path traversal
        // (e.g., after `if '../' in var: return` guard)
        let mut path_sanitized_vars: HashSet<String> = HashSet::new();

        // Track which flow states each variable has been sanitized for
        // This enables context-specific sanitization: escapeHtml sanitizes for Html, not for Sql
        let mut sanitized_for_vars: HashMap<String, HashSet<FlowState>> = HashMap::new();

        // Traverse AST and track taint with symbolic evaluation
        self.track_taint_in_ast(ast, &mut tainted_vars, &mut vulnerabilities, &mut sym_state, &mut list_sizes, &mut path_sanitized_vars, &mut sanitized_for_vars);

        TaintAnalysisResult { vulnerabilities }
    }

    /// Track taint through AST using function summaries
    ///
    /// This method now supports:
    /// - STRONG UPDATES for assignments that are unconditionally executed
    /// - CONSTANT PROPAGATION to eliminate infeasible branches
    /// - INDEX-AWARE LIST TRACKING for ArrayList operations
    /// - PATH TRAVERSAL VALIDATION GUARDS (detecting '../' in var checks)
    /// - CONTEXT-SPECIFIC SANITIZATION tracking (e.g., escapeHtml sanitizes for Html only)
    fn track_taint_in_ast(
        &self,
        node: &AstNode,
        tainted_vars: &mut HashSet<String>,
        vulnerabilities: &mut Vec<TaintVulnerability>,
        sym_state: &mut SymbolicState,
        list_sizes: &mut HashMap<String, usize>,
        path_sanitized_vars: &mut HashSet<String>,
        sanitized_for_vars: &mut HashMap<String, HashSet<FlowState>>,
    ) {
        self.track_taint_in_ast_with_depth(node, tainted_vars, vulnerabilities, 0, 0, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
    }

    /// Internal taint tracking with depth tracking for strong updates
    ///
    /// The `branch_depth` parameter tracks how many conditional branches
    /// we're currently inside. When branch_depth == 0, we can safely
    /// perform strong updates (kill taint on clean assignments).
    ///
    /// The `ast_depth` parameter tracks recursion depth to prevent stack overflow.
    ///
    /// The `sym_state` parameter tracks symbolic values for constant propagation,
    /// allowing us to eliminate infeasible branches.
    ///
    /// The `list_sizes` parameter tracks the current size of each ArrayList
    /// for precise index-based taint tracking.
    ///
    /// The `path_sanitized_vars` parameter tracks variables validated for path traversal
    /// through patterns like `if '../' in var: return` - after such a guard, the variable
    /// is known to NOT contain path traversal sequences.
    ///
    /// The `sanitized_for_vars` parameter tracks which flow states each variable has been
    /// sanitized for. This enables context-specific sanitization: escapeHtml sanitizes for
    /// Html but not for Sql.
    fn track_taint_in_ast_with_depth(
        &self,
        node: &AstNode,
        tainted_vars: &mut HashSet<String>,
        vulnerabilities: &mut Vec<TaintVulnerability>,
        branch_depth: usize,
        ast_depth: usize,
        sym_state: &mut SymbolicState,
        list_sizes: &mut HashMap<String, usize>,
        path_sanitized_vars: &mut HashSet<String>,
        sanitized_for_vars: &mut HashMap<String, HashSet<FlowState>>,
    ) {
        // Prevent stack overflow on deeply nested ASTs
        const MAX_AST_DEPTH: usize = 500;
        if ast_depth > MAX_AST_DEPTH {
            return;
        }

        match &node.kind {
            // Variable declaration with initialization
            AstNodeKind::VariableDeclaration { name, .. } => {
                // Debug: show all children for variable declarations
                #[cfg(debug_assertions)]
                {
                    eprintln!("[DEBUG] VariableDeclaration '{}' has {} children:", name, node.children.len());
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                    }
                }

                // First, process all children to handle nested declarations and expressions
                // This ensures ternaries are evaluated before we check for taint
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                }

                // Track the symbolic value of this variable
                // Recursively search children for a concrete value
                fn find_first_value(node: &AstNode, analyzer: &InterproceduralTaintAnalysis, sym_state: &SymbolicState) -> SymbolicValue {
                    for child in &node.children {
                        let eval = analyzer.evaluate_symbolic(child, sym_state);
                        if !matches!(eval, SymbolicValue::Unknown) {
                            return eval;
                        }
                        // Recursively check children
                        let nested = find_first_value(child, analyzer, sym_state);
                        if !matches!(nested, SymbolicValue::Unknown) {
                            return nested;
                        }
                    }
                    SymbolicValue::Unknown
                }
                let sym_value = find_first_value(node, self, sym_state);
                #[cfg(debug_assertions)]
                eprintln!("[DEBUG] VariableDeclaration: {} = {:?}", name, sym_value);
                sym_state.set(name.clone(), sym_value);

                // Check if initializer is a sanitizer call - track context-specific sanitization
                // Look for CallExpression in children (the initializer)
                for child in &node.children {
                    if let AstNodeKind::CallExpression { callee, .. } = &child.kind {
                        if let Some(sanitizer_states) = self.get_sanitizer_flow_states(callee) {
                            // Record that this variable has been sanitized for specific states
                            let var_sanitized = sanitized_for_vars.entry(name.clone()).or_insert_with(HashSet::new);
                            if sanitizer_states.is_empty() {
                                // Universal sanitizer - mark as sanitized for all states
                                var_sanitized.insert(FlowState::Sql);
                                var_sanitized.insert(FlowState::Html);
                                var_sanitized.insert(FlowState::Shell);
                                var_sanitized.insert(FlowState::Path);
                                var_sanitized.insert(FlowState::Ldap);
                                var_sanitized.insert(FlowState::Xml);
                                var_sanitized.insert(FlowState::Generic);
                            } else {
                                // Context-specific sanitizer
                                for state in sanitizer_states {
                                    var_sanitized.insert(state);
                                }
                            }
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG]     -> VariableDeclaration '{}' sanitized for states: {:?}", name, var_sanitized);
                        }
                        break; // Only check the first CallExpression (the initializer)
                    }
                }

                // Check if initializer is tainted
                if self.is_initializer_tainted(node, tainted_vars) {
                    tainted_vars.insert(name.clone());
                } else if branch_depth == 0 {
                    // STRONG UPDATE: If not in a branch and initializer is clean,
                    // this declaration shadows any previous taint
                    tainted_vars.remove(name);
                    sanitized_for_vars.remove(name);
                }
                // Children already processed above, don't process again
                return;
            }

            // Assignment expression (x = taintedValue)
            AstNodeKind::AssignmentExpression { operator, .. } => {
                #[cfg(debug_assertions)]
                {
                    eprintln!("[DEBUG] AssignmentExpression op='{}' with {} children:", operator, node.children.len());
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                    }
                }
                // AST structure: [LHS, "=", RHS] - so RHS is at index 2
                // Or sometimes: [LHS, RHS] - so RHS is at index 1
                let lhs = node.children.first();
                let rhs = if node.children.len() == 3 {
                    node.children.get(2) // Skip the "=" operator
                } else {
                    node.children.get(1)
                };

                if let (Some(lhs), Some(rhs)) = (lhs, rhs) {
                    // Track symbolic value of the assignment
                    if let AstNodeKind::Identifier { name } = &lhs.kind {
                        let sym_value = self.evaluate_symbolic(rhs, sym_state);
                        sym_state.set(name.clone(), sym_value);
                    }

                    // Check if RHS is tainted (use symbolic evaluation for ternaries)
                    let rhs_tainted = self.is_node_tainted_with_sym(rhs, tainted_vars, sym_state);

                    // Handle Python dictionary subscript assignment: map['key'] = value
                    // LHS is Other { node_type: "subscript" }
                    if matches!(&lhs.kind, AstNodeKind::Other { node_type } if node_type == "subscript") {
                        // Extract base variable and key from subscript
                        // Python subscript structure: base[key] -> children are [base, "[", key, "]"] or [base, key]
                        let base_var = lhs.children.first().map(|n| {
                            if let AstNodeKind::Identifier { name } = &n.kind {
                                name.clone()
                            } else {
                                n.text.trim().to_string()
                            }
                        });

                        // Extract key - look for string literal in children
                        let key = lhs.children.iter().find_map(|child| {
                            match &child.kind {
                                AstNodeKind::Literal { value: LiteralValue::String(s) } => {
                                    Some(s.trim_matches(|c| c == '\'' || c == '"').to_string())
                                }
                                _ if child.text.starts_with('\'') || child.text.starts_with('"') => {
                                    let text = child.text.trim_matches(|c| c == '\'' || c == '"');
                                    Some(text.to_string())
                                }
                                _ => None
                            }
                        });

                        if let (Some(base), Some(key)) = (base_var, key) {
                            let map_key = format!("{}[{}]", base, key);
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG] Subscript assignment: {} = rhs_tainted={}", map_key, rhs_tainted);
                            if rhs_tainted {
                                tainted_vars.insert(map_key);
                            } else {
                                tainted_vars.remove(&map_key);
                            }
                        }
                    }

                    // Extract LHS variable name
                    if let AstNodeKind::Identifier { name } = &lhs.kind {
                        #[cfg(debug_assertions)]
                        eprintln!("[DEBUG]   Assignment to '{}': rhs_tainted={}, branch_depth={}", name, rhs_tainted, branch_depth);

                        // Check if RHS is a sanitizer call - track context-specific sanitization
                        if let AstNodeKind::CallExpression { callee, .. } = &rhs.kind {
                            if let Some(sanitizer_states) = self.get_sanitizer_flow_states(callee) {
                                // Record that this variable has been sanitized for specific states
                                let var_sanitized = sanitized_for_vars.entry(name.clone()).or_insert_with(HashSet::new);
                                if sanitizer_states.is_empty() {
                                    // Universal sanitizer - mark as sanitized for all states
                                    var_sanitized.insert(FlowState::Sql);
                                    var_sanitized.insert(FlowState::Html);
                                    var_sanitized.insert(FlowState::Shell);
                                    var_sanitized.insert(FlowState::Path);
                                    var_sanitized.insert(FlowState::Ldap);
                                    var_sanitized.insert(FlowState::Xml);
                                    var_sanitized.insert(FlowState::Generic);
                                } else {
                                    // Context-specific sanitizer
                                    for state in sanitizer_states {
                                        var_sanitized.insert(state);
                                    }
                                }
                                #[cfg(debug_assertions)]
                                eprintln!("[DEBUG]     -> Marked '{}' as sanitized for states: {:?}", name, var_sanitized);
                            }
                        }

                        if rhs_tainted {
                            // Add taint if RHS is tainted
                            tainted_vars.insert(name.clone());
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG]     -> Added taint to '{}'", name);
                        } else if branch_depth == 0 {
                            // STRONG UPDATE: If not inside a branch and RHS is clean,
                            // we can safely remove taint from LHS.
                            // This is the key fix for precision - when we see:
                            //   x = tainted;
                            //   x = "safe";  // <-- this kills the taint
                            //   sink(x);     // <-- should NOT report
                            tainted_vars.remove(name);
                            // Also clear sanitization tracking for the variable
                            sanitized_for_vars.remove(name);
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG]     -> Removed taint from '{}' (strong update)", name);
                        }
                        // NOTE: When branch_depth > 0, we're inside a conditional
                        // (if/else/switch/loop), so we can't do strong updates
                        // because the assignment might not always execute.
                    }
                }
            }

            // Function call
            AstNodeKind::CallExpression { callee, .. } => {
                #[cfg(debug_assertions)]
                {
                    if callee.contains(".put") || callee.contains(".get") {
                        eprintln!("[DEBUG] CallExpression: callee='{}' with {} children", callee, node.children.len());
                        for (i, child) in node.children.iter().enumerate() {
                            eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                        }
                    }
                }
                // Track map.put() operations for content tracking
                // Pattern: mapVar.put("key", value)
                if callee.ends_with(".put") {
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG] Processing map.put() for content tracking");
                    let parts: Vec<&str> = callee.rsplitn(2, '.').collect();
                    if parts.len() == 2 {
                        let map_var = parts[1]; // Variable name before .put
                        #[cfg(debug_assertions)]
                        eprintln!("[DEBUG]   map_var='{}', looking for argument_list", map_var);
                        // Look for arguments: first is key, second is value
                        // Children structure: [receiver, arguments] or [arguments]
                        // Find the argument list
                        for (idx, child) in node.children.iter().enumerate() {
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG]   child[{}]: kind={:?} text='{}'", idx, child.kind, child.text.lines().next().unwrap_or(""));
                            if matches!(&child.kind, AstNodeKind::Other { node_type } if node_type == "argument_list") {
                                #[cfg(debug_assertions)]
                                eprintln!("[DEBUG]   Found argument_list with {} children", child.children.len());
                                let args: Vec<&AstNode> = child.children.iter()
                                    .filter(|c| !matches!(&c.kind, AstNodeKind::Other { node_type } if node_type == "(" || node_type == ")" || node_type == ","))
                                    .collect();
                                #[cfg(debug_assertions)]
                                {
                                    eprintln!("[DEBUG]   Filtered args: {} items", args.len());
                                    for (i, arg) in args.iter().enumerate() {
                                        eprintln!("[DEBUG]     arg[{}]: kind={:?} text='{}'", i, arg.kind, arg.text.lines().next().unwrap_or(""));
                                    }
                                }
                                if args.len() >= 2 {
                                    // Get the key (first arg) - handle both String literal and string with quotes
                                    let key_opt = match &args[0].kind {
                                        AstNodeKind::Literal { value: LiteralValue::String(key) } => {
                                            // Strip quotes if present
                                            let k = key.trim_matches('"');
                                            Some(k.to_string())
                                        }
                                        _ => {
                                            // Try to extract from text (for Java string_literal parsed as Other)
                                            let text = args[0].text.trim();
                                            if text.starts_with('"') && text.ends_with('"') {
                                                Some(text[1..text.len()-1].to_string())
                                            } else {
                                                None
                                            }
                                        }
                                    };
                                    #[cfg(debug_assertions)]
                                    eprintln!("[DEBUG]   Extracted key: {:?}", key_opt);
                                    if let Some(key) = key_opt {
                                        // Get the value (second arg) symbolically
                                        let val_sym = self.evaluate_symbolic(args[1], sym_state);
                                        let val_tainted = self.is_node_tainted_with_sym(args[1], tainted_vars, sym_state);

                                        // Store in symbolic state as mapVar["key"]
                                        let map_key = format!("{}[{}]", map_var, key);
                                        sym_state.set(map_key, val_sym);

                                        // Track taint for the map key
                                        let map_key_taint = format!("{}[{}]", map_var, key);
                                        #[cfg(debug_assertions)]
                                        eprintln!("[DEBUG]   Setting map_key='{}', val_tainted={}", map_key_taint, val_tainted);
                                        if val_tainted {
                                            tainted_vars.insert(map_key_taint);
                                        } else {
                                            tainted_vars.remove(&map_key_taint);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Track list.add() operations for ArrayList content tracking with index precision
                // Pattern: listVar.add(value) - track taint at specific index
                if callee.ends_with(".add") {
                    let parts: Vec<&str> = callee.rsplitn(2, '.').collect();
                    if parts.len() == 2 {
                        let list_var = parts[1];
                        // Find the argument
                        for child in &node.children {
                            if matches!(&child.kind, AstNodeKind::Other { node_type } if node_type == "argument_list") {
                                let args: Vec<&AstNode> = child.children.iter()
                                    .filter(|c| !matches!(&c.kind, AstNodeKind::Other { node_type } if node_type == "(" || node_type == ")" || node_type == ","))
                                    .collect();
                                if !args.is_empty() {
                                    let val_tainted = self.is_node_tainted_with_sym(args[0], tainted_vars, sym_state);
                                    // Get current list size and increment
                                    let current_size = list_sizes.get(list_var).copied().unwrap_or(0);
                                    #[cfg(debug_assertions)]
                                    eprintln!("[DEBUG] list.add() - list_var='{}', index={}, val_tainted={}", list_var, current_size, val_tainted);
                                    if val_tainted {
                                        // Track taint at specific index: listVar@index
                                        tainted_vars.insert(format!("{}@{}", list_var, current_size));
                                    }
                                    // Increment list size
                                    list_sizes.insert(list_var.to_string(), current_size + 1);
                                }
                            }
                        }
                    }
                }

                // Track list.remove(index) operations - shift tainted indices
                // Pattern: listVar.remove(index) - shift all taint markers above index down by 1
                if callee.ends_with(".remove") {
                    let parts: Vec<&str> = callee.rsplitn(2, '.').collect();
                    if parts.len() == 2 {
                        let list_var = parts[1];
                        // Find the index argument
                        for child in &node.children {
                            if matches!(&child.kind, AstNodeKind::Other { node_type } if node_type == "argument_list") {
                                let args: Vec<&AstNode> = child.children.iter()
                                    .filter(|c| !matches!(&c.kind, AstNodeKind::Other { node_type } if node_type == "(" || node_type == ")" || node_type == ","))
                                    .collect();
                                if !args.is_empty() {
                                    // Try to get the index value
                                    let removed_index: Option<usize> = match &args[0].kind {
                                        AstNodeKind::Literal { value: LiteralValue::Number(n) } => {
                                            n.parse::<usize>().ok()
                                        }
                                        _ => {
                                            // Try to evaluate symbolically
                                            match self.evaluate_symbolic(args[0], sym_state) {
                                                SymbolicValue::Concrete(n) if n >= 0 => Some(n as usize),
                                                _ => None,
                                            }
                                        }
                                    };

                                    if let Some(idx) = removed_index {
                                        let current_size = list_sizes.get(list_var).copied().unwrap_or(0);
                                        #[cfg(debug_assertions)]
                                        eprintln!("[DEBUG] list.remove({}) - list_var='{}', shifting indices", idx, list_var);

                                        // Remove taint at removed index
                                        tainted_vars.remove(&format!("{}@{}", list_var, idx));

                                        // Shift all indices above the removed one down by 1
                                        // Collect indices to shift first
                                        let mut to_shift: Vec<usize> = Vec::new();
                                        for i in (idx + 1)..current_size {
                                            if tainted_vars.contains(&format!("{}@{}", list_var, i)) {
                                                to_shift.push(i);
                                            }
                                        }

                                        // Now perform the shifts
                                        for i in to_shift {
                                            tainted_vars.remove(&format!("{}@{}", list_var, i));
                                            tainted_vars.insert(format!("{}@{}", list_var, i - 1));
                                            #[cfg(debug_assertions)]
                                            eprintln!("[DEBUG]   Shifted {}@{} to {}@{}", list_var, i, list_var, i - 1);
                                        }

                                        // Decrement list size
                                        if current_size > 0 {
                                            list_sizes.insert(list_var.to_string(), current_size - 1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Note: Source function detection is now handled in AssignmentExpression
                // and VariableDeclaration handlers via is_node_tainted_with_sym().
                // We don't add the callee name directly to tainted_vars here because
                // that would incorrectly treat the function NAME as tainted rather than
                // its RESULT.

                // Check if this is a sink with tainted data
                if self.is_sink_function(callee) {
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG] Checking sink '{}' at branch_depth={}", callee, branch_depth);

                    // Use language handler to check for safe sink patterns
                    // (e.g., parameterized queries, prepared statements, etc.)
                    let safe_pattern = self.language_handler.detect_safe_sink_pattern(callee, node);
                    if safe_pattern != SafeSinkPattern::None {
                        #[cfg(debug_assertions)]
                        eprintln!("[DEBUG]   Skipping safe sink pattern: {:?}", safe_pattern);
                        // Don't flag safe patterns as vulnerabilities
                    } else {
                        // Check if any arguments are tainted (use symbolic evaluation)
                        let has_tainted = self.has_tainted_arguments(node, tainted_vars, sym_state);
                        #[cfg(debug_assertions)]
                        {
                            eprintln!("[DEBUG]   has_tainted_arguments={}", has_tainted);
                            eprintln!("[DEBUG]   Current tainted_vars: {:?}", tainted_vars);
                        }
                        if has_tainted {
                            // Create vulnerability
                            let sink_found = self.find_sink_by_name(callee);
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG]   find_sink_by_name('{}') = {:?}", callee, sink_found.is_some());
                            if let Some(sink) = sink_found {
                                // Get the FlowState for this sink
                                let sink_flow_state = FlowState::from_sink_kind(&sink.kind);

                                // Check if tainted arguments are sanitized for this specific sink
                                let all_sanitized = self.are_tainted_args_sanitized_for_state(
                                    node, tainted_vars, sym_state, sanitized_for_vars, &sink_flow_state
                                );

                                if all_sanitized {
                                    #[cfg(debug_assertions)]
                                    eprintln!("[DEBUG]   Skipping vulnerability - tainted args are sanitized for {:?}", sink_flow_state);
                                } else {
                                    #[cfg(debug_assertions)]
                                    eprintln!("[DEBUG]   Creating vulnerability for sink: {}", sink.name);
                                    let message = format!(
                                        "{} vulnerability - untrusted data in {}",
                                        match sink.kind {
                                            TaintSinkKind::SqlQuery => "SQL injection",
                                            TaintSinkKind::CommandExecution => "Command injection",
                                            TaintSinkKind::FileWrite => "Path traversal",
                                            TaintSinkKind::CodeEval => "Code injection",
                                            TaintSinkKind::HtmlOutput => "Cross-site scripting (XSS)",
                                            TaintSinkKind::LogOutput => "Log injection",
                                            TaintSinkKind::NetworkSend => "Server-side request forgery",
                                        },
                                        sink.name
                                    );
                                    vulnerabilities.push(TaintVulnerability {
                                        sink: sink.clone(),
                                        tainted_value: TaintValue::new(
                                            callee.clone(),
                                            TaintSourceKind::UserInput,
                                        ),
                                        severity: Severity::High,
                                        file_path: node.location.file_path.clone(),
                                        line: node.location.span.start_line,
                                        column: node.location.span.start_column,
                                        message,
                                    });
                                }
                            }
                        }
                    }
                }

                // Note: Taint from function return values is now tracked via
                // AssignmentExpression and VariableDeclaration handlers above.
                // The is_node_tainted() method checks if a CallExpression returns
                // taint based on function summaries.
            }

            // Handle Java object creation expressions: new ClassName(args)
            // Tree-sitter Java parses this as object_creation_expression
            //
            // TODO: Refactor to language_handler.rs - this is Java-specific logic that should
            // be delegated to LanguageTaintHandler::is_constructor_sink() to keep the core
            // algorithm language-agnostic. See also the cookie/headers source detection below.
            AstNodeKind::Other { node_type } if node_type == "object_creation_expression" => {
                // Extract the class name from the object creation
                // Structure: new + type_identifier + argument_list
                let mut class_name: Option<String> = None;
                let mut has_tainted_args = false;

                for child in &node.children {
                    match &child.kind {
                        AstNodeKind::Identifier { name } => {
                            if class_name.is_none() {
                                class_name = Some(name.clone());
                            }
                        }
                        AstNodeKind::Other { node_type: child_type } => {
                            if child_type == "type_identifier" || child_type == "generic_type" {
                                // Extract class name from type identifier
                                class_name = Some(child.text.trim().to_string());
                            } else if child_type == "argument_list" {
                                // Check if any arguments are tainted
                                for arg in &child.children {
                                    if !matches!(&arg.kind, AstNodeKind::Other { node_type: t } if t == "(" || t == ")" || t == ",") {
                                        if self.is_node_tainted_with_sym(arg, tainted_vars, sym_state) {
                                            has_tainted_args = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }

                // Check if the class is a sink (e.g., ProcessBuilder, Runtime)
                if let Some(ref cname) = class_name {
                    let cname_lower = cname.to_lowercase();
                    // Check for command execution constructors
                    let is_cmd_sink = cname_lower.contains("processbuilder")
                        || cname_lower.contains("runtime")
                        || cname_lower.contains("commandline");

                    if is_cmd_sink && has_tainted_args {
                        #[cfg(debug_assertions)]
                        eprintln!("[DEBUG] Found tainted object creation sink: new {}(...)", cname);

                        let sink = TaintSink {
                            name: format!("new {}", cname),
                            kind: TaintSinkKind::CommandExecution,
                            node_id: node.id,
                        };
                        let message = format!(
                            "Command injection vulnerability - untrusted data in new {}",
                            cname
                        );
                        vulnerabilities.push(TaintVulnerability {
                            sink,
                            tainted_value: TaintValue::new(
                                cname.clone(),
                                TaintSourceKind::UserInput,
                            ),
                            severity: Severity::High,
                            file_path: node.location.file_path.clone(),
                            line: node.location.span.start_line,
                            column: node.location.span.start_column,
                            message,
                        });
                    }
                }

                // Recurse into children
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(
                        child, tainted_vars, vulnerabilities, branch_depth, ast_depth + 1,
                        sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                    );
                }
                return;
            }

            AstNodeKind::FunctionDeclaration { .. } | AstNodeKind::MethodDeclaration { .. } => {
                // Enter new scope - analyze function body with fresh taint set and symbolic state
                // Reset branch_depth to 0 since we're in a new function scope
                let mut local_tainted = HashSet::new();
                let mut local_sym_state = SymbolicState::new();
                let mut local_list_sizes = HashMap::new();
                let mut local_path_sanitized = HashSet::new();
                let mut local_sanitized_for = HashMap::new();
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, &mut local_tainted, vulnerabilities, 0, ast_depth + 1, &mut local_sym_state, &mut local_list_sizes, &mut local_path_sanitized, &mut local_sanitized_for);
                }
                return; // Don't propagate local taint to parent scope
            }

            // Conditional expression (ternary) - use constant propagation!
            // Uses language handler to get correct indices for Python vs Java ternaries
            AstNodeKind::ConditionalExpression { test, .. } => {
                // Debug: log the ternary expression
                #[cfg(debug_assertions)]
                {
                    eprintln!(
                        "[DEBUG] ConditionalExpression found: test='{}', {} children",
                        test, node.children.len()
                    );
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                    }
                }

                // Use language handler to get correct indices
                let indices = self.language_handler.get_conditional_indices(node);
                let (condition_idx, true_idx, false_idx) = (
                    indices.condition,
                    indices.true_branch,
                    indices.false_branch,
                );

                #[cfg(debug_assertions)]
                eprintln!("[DEBUG]   language={:?}, indices: cond={}, true={}, false={}",
                         self.language_handler.language(), condition_idx, true_idx, false_idx);

                // Try to evaluate the condition symbolically
                if let Some(condition_node) = node.children.get(condition_idx) {
                    let condition = self.evaluate_symbolic(condition_node, sym_state);
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG]   Evaluated condition: {:?}", condition);

                    // Check if condition is definitely true or false
                    match condition.as_definite_bool() {
                        Some(true) => {
                            // Condition is DEFINITELY TRUE - only analyze true branch
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG]   Condition is TRUE, using true branch at index {}", true_idx);
                            if let Some(true_branch) = node.children.get(true_idx) {
                                #[cfg(debug_assertions)]
                                eprintln!("[DEBUG]   True branch: {:?} = '{}'", true_branch.kind, true_branch.text.lines().next().unwrap_or(""));
                                self.track_taint_in_ast_with_depth(
                                    true_branch, tainted_vars, vulnerabilities,
                                    branch_depth, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                                );
                            }
                            return;
                        }
                        Some(false) => {
                            // Condition is DEFINITELY FALSE - only analyze false branch
                            if let Some(false_branch) = node.children.get(false_idx) {
                                self.track_taint_in_ast_with_depth(
                                    false_branch, tainted_vars, vulnerabilities,
                                    branch_depth, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                                );
                            }
                            return;
                        }
                        None => {
                            // Condition is symbolic/unknown - analyze both branches (conservative)
                            // We still increment branch_depth to prevent strong updates
                            for child in &node.children {
                                self.track_taint_in_ast_with_depth(
                                    child, tainted_vars, vulnerabilities,
                                    branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                                );
                            }
                            return;
                        }
                    }
                }
                // Fallback: analyze all children with incremented depth
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                }
                return;
            }

            // If statement - also use constant propagation
            // Java if_statement structure: "if" parenthesized_expression then_clause [else_clause]
            AstNodeKind::IfStatement => {
                #[cfg(debug_assertions)]
                {
                    eprintln!("[DEBUG] IfStatement found with {} children:", node.children.len());
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                    }
                }
                // Find the condition - at index 1 (after "if" keyword)
                // Then branch varies by language:
                // - Java/C: index 2 (if_statement structure: if parenthesized_expression statement)
                // - Python: index 3 (if_statement structure: if condition : block)
                let then_branch_idx = if node.children.len() == 4 &&
                    matches!(&node.children.get(2).map(|c| &c.kind), Some(AstNodeKind::Other { node_type }) if node_type == ":") {
                    3 // Python style
                } else {
                    2 // Java/C style
                };

                if let Some(condition_node) = node.children.get(1) {
                    // Check for validation guard pattern BEFORE evaluating condition
                    // Pattern: if '<dangerous>' in var: return
                    // This means after the if, the variable is guaranteed NOT to contain the dangerous pattern
                    if let Some(then_branch) = node.children.get(then_branch_idx) {
                        #[cfg(debug_assertions)]
                        eprintln!("[DEBUG] Checking validation guard: condition='{}' then_branch={:?}", condition_node.text, then_branch.kind);
                        if let Some(sanitized_var) = self.detect_validation_guard(condition_node, then_branch) {
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG] Found validation guard for variable '{}' - will sanitize after if block", sanitized_var);
                            // Found a validation guard!
                            // Process the then-branch (it might have findings)
                            self.track_taint_in_ast_with_depth(
                                then_branch, tainted_vars, vulnerabilities,
                                branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                            );
                            // Process any else branch
                            for i in 3..node.children.len() {
                                if let Some(else_branch) = node.children.get(i) {
                                    if !matches!(&else_branch.kind, AstNodeKind::Other { node_type } if node_type == "else") {
                                        self.track_taint_in_ast_with_depth(
                                            else_branch, tainted_vars, vulnerabilities,
                                            branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                                        );
                                    }
                                }
                            }
                            // Mark the variable as sanitized
                            // Code AFTER this if statement knows the dangerous pattern is not in the var
                            // Remove from tainted_vars since it has been validated
                            path_sanitized_vars.insert(sanitized_var.clone());
                            tainted_vars.remove(&sanitized_var);
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG] Removed '{}' from tainted_vars after validation guard", sanitized_var);
                            return;
                        }
                    }

                    let condition = self.evaluate_symbolic(condition_node, sym_state);

                    match condition.as_definite_bool() {
                        Some(true) => {
                            // Condition is DEFINITELY TRUE - only analyze then branch (index 2)
                            if let Some(then_branch) = node.children.get(2) {
                                self.track_taint_in_ast_with_depth(
                                    then_branch, tainted_vars, vulnerabilities,
                                    branch_depth, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                                );
                            }
                            return;
                        }
                        Some(false) => {
                            // Condition is DEFINITELY FALSE - only analyze else branch if present
                            // Else branch could be at index 3 or 4 depending on structure
                            for i in 3..node.children.len() {
                                if let Some(else_branch) = node.children.get(i) {
                                    // Skip the "else" keyword
                                    if !matches!(&else_branch.kind, AstNodeKind::Other { node_type } if node_type == "else") {
                                        self.track_taint_in_ast_with_depth(
                                            else_branch, tainted_vars, vulnerabilities,
                                            branch_depth, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                                        );
                                    }
                                }
                            }
                            return;
                        }
                        None => {
                            // Condition is symbolic/unknown - analyze both branches (conservative)
                            for child in &node.children {
                                self.track_taint_in_ast_with_depth(
                                    child, tainted_vars, vulnerabilities,
                                    branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars
                                );
                            }
                            return;
                        }
                    }
                }
                // Fallback
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                }
                return;
            }

            AstNodeKind::SwitchStatement { .. } | AstNodeKind::SwitchCase { .. } => {
                // Inside a switch, we can't do strong updates
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                }
                return;
            }

            // Handle Python match statement with constant propagation
            AstNodeKind::Other { node_type } if node_type == "match_statement" => {
                #[cfg(debug_assertions)]
                {
                    eprintln!("[DEBUG] match_statement with {} children:", node.children.len());
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?}", i, child.kind);
                    }
                }

                // Find the subject (first identifier or expression after "match")
                let subject_node = node.children.iter().find(|c| {
                    matches!(&c.kind, AstNodeKind::Identifier { .. }) ||
                    matches!(&c.kind, AstNodeKind::Other { node_type } if node_type != "match" && node_type != ":" && node_type != "case_clause" && node_type != "block")
                });

                if let Some(subject) = subject_node {
                    let subject_value = self.evaluate_symbolic(subject, sym_state);
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG]   match subject = {:?}", subject_value);

                    // If we have a concrete value, try to find the matching case
                    if let SymbolicValue::ConcreteString(ref val) = subject_value {
                        // Find the block containing case clauses (tree-sitter puts cases inside a block)
                        let block_node = node.children.iter().find(|c| {
                            matches!(&c.kind, AstNodeKind::Block)
                        });

                        #[cfg(debug_assertions)]
                        if let Some(ref block) = block_node {
                            eprintln!("[DEBUG]   Found block with {} children:", block.children.len());
                            for (i, c) in block.children.iter().enumerate() {
                                eprintln!("[DEBUG]     block_child[{}]: {:?}", i, c.kind);
                            }
                        }

                        // Get case clauses from the block or directly from match_statement
                        // They appear as SwitchCase nodes in our AST
                        let case_clauses: Vec<_> = if let Some(block) = block_node {
                            block.children.iter()
                                .filter(|c| matches!(&c.kind, AstNodeKind::SwitchCase { .. }) ||
                                           matches!(&c.kind, AstNodeKind::Other { node_type } if node_type == "case_clause"))
                                .collect()
                        } else {
                            node.children.iter()
                                .filter(|c| matches!(&c.kind, AstNodeKind::SwitchCase { .. }) ||
                                           matches!(&c.kind, AstNodeKind::Other { node_type } if node_type == "case_clause"))
                                .collect()
                        };

                        #[cfg(debug_assertions)]
                        eprintln!("[DEBUG]   Found {} case clauses", case_clauses.len());

                        for case_clause in &case_clauses {
                            #[cfg(debug_assertions)]
                            {
                                eprintln!("[DEBUG]   case_clause: {:?}", case_clause.kind);
                                for (i, c) in case_clause.children.iter().enumerate() {
                                    eprintln!("[DEBUG]     [{}]: {:?} = '{}'", i, c.kind, c.text.lines().next().unwrap_or(""));
                                }
                            }

                            // Check if this case's pattern matches
                            let pattern_matches = case_clause.children.iter().any(|pattern_child| {
                                // Look for string literal patterns like 'B' or "B"
                                if let Some(pattern_val) = self.language_handler.evaluate_literal(pattern_child) {
                                    if let SymbolicValue::ConcreteString(ref pattern_str) = pattern_val {
                                        #[cfg(debug_assertions)]
                                        eprintln!("[DEBUG]     Comparing pattern '{}' with subject '{}'", pattern_str, val);
                                        return pattern_str == val;
                                    }
                                }
                                // Also check for case_pattern nodes
                                if let AstNodeKind::Other { node_type } = &pattern_child.kind {
                                    if node_type == "case_pattern" {
                                        // Look for string literals inside the pattern
                                        for inner in &pattern_child.children {
                                            if let Some(pattern_val) = self.language_handler.evaluate_literal(inner) {
                                                if let SymbolicValue::ConcreteString(ref pattern_str) = pattern_val {
                                                    #[cfg(debug_assertions)]
                                                    eprintln!("[DEBUG]     Comparing inner pattern '{}' with subject '{}'", pattern_str, val);
                                                    return pattern_str == val;
                                                }
                                            }
                                        }
                                    }
                                }
                                false
                            });

                            // Check for default case (typically has "_" pattern)
                            let is_default = case_clause.children.iter().any(|c| c.text.trim() == "_");

                            if pattern_matches {
                                // This case matches - analyze only this branch at current depth
                                #[cfg(debug_assertions)]
                                eprintln!("[DEBUG]   Found matching case for '{}'", val);
                                for case_child in &case_clause.children {
                                    // Skip the pattern itself, just process the body (block)
                                    if matches!(&case_child.kind, AstNodeKind::Block) ||
                                       matches!(&case_child.kind, AstNodeKind::Other { node_type } if node_type == "block") {
                                        self.track_taint_in_ast_with_depth(case_child, tainted_vars, vulnerabilities, branch_depth, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                                    }
                                }
                                return;
                            } else if is_default {
                                // Default case - only use if no other case matched
                                // (handled by falling through if no pattern_matches)
                            }
                        }
                    }
                }

                // If we can't determine the match, analyze all branches conservatively
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                }
                return;
            }

            AstNodeKind::WhileStatement | AstNodeKind::ForStatement { .. } | AstNodeKind::DoWhileStatement => {
                // Inside a loop, we can't do strong updates
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                }
                return;
            }

            AstNodeKind::TryStatement | AstNodeKind::CatchClause { .. } => {
                // Inside try/catch, we can't do strong updates
                for child in &node.children {
                    self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth + 1, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
                }
                return;
            }

            _ => {}
        }

        // Recursively process children (preserving branch depth)
        for child in &node.children {
            self.track_taint_in_ast_with_depth(child, tainted_vars, vulnerabilities, branch_depth, ast_depth + 1, sym_state, list_sizes, path_sanitized_vars, sanitized_for_vars);
        }
    }

    /// Evaluate an AST node to a symbolic value for constant propagation
    /// Uses language handler for language-specific literal and operator evaluation
    fn evaluate_symbolic(&self, node: &AstNode, sym_state: &SymbolicState) -> SymbolicValue {
        // First try language handler for literals (handles Python integer, float, etc.)
        if let Some(value) = self.language_handler.evaluate_literal(node) {
            return value;
        }

        // Then try language handler for binary operators (Python binary_operator)
        if let Some(value) = self.language_handler.evaluate_binary_op(node, sym_state) {
            return value;
        }

        // Then try language handler for comparisons (Python comparison_operator)
        if let Some(value) = self.language_handler.evaluate_comparison(node, sym_state) {
            return value;
        }

        // Fall back to generic handling
        match &node.kind {
            AstNodeKind::Identifier { name } => {
                // Look up in symbolic state
                sym_state.get(name)
            }

            AstNodeKind::BinaryExpression { operator } => {
                #[cfg(debug_assertions)]
                {
                    eprintln!("[DEBUG] BinaryExpression op='{}' with {} children:", operator, node.children.len());
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                    }
                }
                // Handle both 2-child (left, right) and 3-child (left, op, right) formats
                // Java/C often use 3 children: left, operator, right
                let (left_idx, right_idx) = if node.children.len() == 3 {
                    (0, 2) // Skip the operator node in the middle
                } else {
                    (0, 1)
                };
                if node.children.len() >= 2 {
                    let left = self.evaluate_symbolic(&node.children[left_idx], sym_state);
                    let right = self.evaluate_symbolic(&node.children[right_idx], sym_state);
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG]   left={:?}, right={:?}", left, right);

                    let op = match operator.as_str() {
                        "+" => BinaryOperator::Add,
                        "-" => BinaryOperator::Subtract,
                        "*" => BinaryOperator::Multiply,
                        "/" => BinaryOperator::Divide,
                        "%" => BinaryOperator::Modulo,
                        "==" | "===" => BinaryOperator::Equal,
                        "!=" | "!==" => BinaryOperator::NotEqual,
                        "<" => BinaryOperator::LessThan,
                        "<=" => BinaryOperator::LessThanOrEqual,
                        ">" => BinaryOperator::GreaterThan,
                        ">=" => BinaryOperator::GreaterThanOrEqual,
                        "&&" => BinaryOperator::And,
                        "||" => BinaryOperator::Or,
                        "&" => BinaryOperator::BitwiseAnd,
                        "|" => BinaryOperator::BitwiseOr,
                        "^" => BinaryOperator::BitwiseXor,
                        "<<" => BinaryOperator::LeftShift,
                        ">>" => BinaryOperator::RightShift,
                        _ => return SymbolicValue::Unknown,
                    };

                    SymbolicValue::binary(op, left, right).simplify()
                } else {
                    SymbolicValue::Unknown
                }
            }

            AstNodeKind::UnaryExpression { operator } => {
                if let Some(operand_node) = node.children.first() {
                    let operand = self.evaluate_symbolic(operand_node, sym_state);

                    let op = match operator.as_str() {
                        "!" => UnaryOperator::Not,
                        "-" => UnaryOperator::Negate,
                        "~" => UnaryOperator::BitwiseNot,
                        _ => return SymbolicValue::Unknown,
                    };

                    SymbolicValue::UnaryOp {
                        operator: op,
                        operand: Box::new(operand),
                    }.simplify()
                } else {
                    SymbolicValue::Unknown
                }
            }

            AstNodeKind::ParenthesizedExpression => {
                #[cfg(debug_assertions)]
                {
                    eprintln!("[DEBUG] ParenthesizedExpression with {} children:", node.children.len());
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                    }
                }
                // The inner expression - skip leading ( and trailing )
                // For 3 children: (expr), the expression is at index 1
                // For 1 child: just the expression
                let inner_idx = if node.children.len() == 3 { 1 } else { 0 };
                if let Some(inner) = node.children.get(inner_idx) {
                    self.evaluate_symbolic(inner, sym_state)
                } else {
                    SymbolicValue::Unknown
                }
            }

            // Handle Python subscript (string/list indexing): possible[1]
            // This is critical for match statement constant propagation
            AstNodeKind::Other { node_type } if node_type == "subscript" => {
                #[cfg(debug_assertions)]
                {
                    eprintln!("[DEBUG] Subscript with {} children:", node.children.len());
                    for (i, child) in node.children.iter().enumerate() {
                        eprintln!("[DEBUG]   child[{}]: {:?} = '{}'", i, child.kind, child.text.lines().next().unwrap_or(""));
                    }
                }
                // Python subscript structure: base[index]
                // children are typically: [base, "[", index, "]"] or [base, index]
                if let Some(base_node) = node.children.first() {
                    let base_val = self.evaluate_symbolic(base_node, sym_state);

                    // Find the index - skip "[" brackets
                    let index_node = node.children.iter().find(|c| {
                        !matches!(&c.kind, AstNodeKind::Other { node_type }
                            if node_type == "[" || node_type == "]")
                        && c.id != base_node.id
                    });

                    if let Some(idx_node) = index_node {
                        let idx_val = self.evaluate_symbolic(idx_node, sym_state);

                        // If we have a concrete string and concrete index, extract the character
                        if let (SymbolicValue::ConcreteString(s), SymbolicValue::Concrete(idx)) = (&base_val, &idx_val) {
                            let idx = *idx as usize;
                            if idx < s.len() {
                                let ch = s.chars().nth(idx).unwrap_or('\0');
                                #[cfg(debug_assertions)]
                                eprintln!("[DEBUG]   Subscript result: '{}'[{}] = '{}'", s, idx, ch);
                                return SymbolicValue::ConcreteString(ch.to_string());
                            }
                        }
                    }
                }
                SymbolicValue::Unknown
            }

            // For call expressions, function results, etc. - return Unknown
            // (we don't know what they return without executing them)
            _ => SymbolicValue::Unknown,
        }
    }

    /// Check if initializer expression is tainted
    fn is_initializer_tainted(&self, node: &AstNode, tainted_vars: &HashSet<String>) -> bool {
        // Check children for tainted references or source calls
        for child in &node.children {
            if let AstNodeKind::CallExpression { callee, .. } = &child.kind {
                if self.is_source_function(callee) {
                    return true;
                }
                if let Some(summary) = self.summaries.get(callee) {
                    if summary.generates_taint || summary.returns_taint {
                        return true;
                    }
                }
            }

            if let AstNodeKind::Identifier { name } = &child.kind {
                if tainted_vars.contains(name) {
                    return true;
                }
            }

            // Recursively check
            if self.is_node_tainted(child, tainted_vars) {
                return true;
            }
        }

        false
    }

    /// Check if a node contains tainted data
    /// Uses symbolic evaluation to handle ternary expressions properly
    fn is_node_tainted(&self, node: &AstNode, tainted_vars: &HashSet<String>) -> bool {
        self.is_node_tainted_with_sym(node, tainted_vars, &SymbolicState::new())
    }

    /// Check if a node contains tainted data, using symbolic state
    fn is_node_tainted_with_sym(&self, node: &AstNode, tainted_vars: &HashSet<String>, sym_state: &SymbolicState) -> bool {
        match &node.kind {
            AstNodeKind::Identifier { name } => {
                // Direct taint check
                if tainted_vars.contains(name) {
                    return true;
                }
                // Implicit read for collections: if any element is tainted, the collection is tainted
                // This handles patterns like: list.add(tainted); sink(list)
                // We track list elements as "listVar@0", "listVar@1", etc.
                let prefix = format!("{}@", name);
                if tainted_vars.iter().any(|v| v.starts_with(&prefix)) {
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG] Implicit read: collection '{}' has tainted elements", name);
                    return true;
                }
                // Also check for map elements: "mapVar[key]"
                let map_prefix = format!("{}[", name);
                if tainted_vars.iter().any(|v| v.starts_with(&map_prefix)) {
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG] Implicit read: map '{}' has tainted values", name);
                    return true;
                }
                false
            }

            // Handle conditional expressions (ternaries) with symbolic evaluation
            // Uses language handler to get correct indices for Python vs Java ternaries
            AstNodeKind::ConditionalExpression { .. } => {
                // Use language handler to get correct indices
                let indices = self.language_handler.get_conditional_indices(node);
                let (condition_idx, true_idx, false_idx) = (
                    indices.condition,
                    indices.true_branch,
                    indices.false_branch,
                );

                if let Some(condition_node) = node.children.get(condition_idx) {
                    let condition = self.evaluate_symbolic(condition_node, sym_state);
                    match condition.as_definite_bool() {
                        Some(true) => {
                            // Condition is definitely TRUE - only check true branch
                            if let Some(true_branch) = node.children.get(true_idx) {
                                return self.is_node_tainted_with_sym(true_branch, tainted_vars, sym_state);
                            }
                            false
                        }
                        Some(false) => {
                            // Condition is definitely FALSE - only check false branch
                            if let Some(false_branch) = node.children.get(false_idx) {
                                return self.is_node_tainted_with_sym(false_branch, tainted_vars, sym_state);
                            }
                            false
                        }
                        None => {
                            // Unknown condition - conservatively check both branches
                            node.children.iter().any(|c| self.is_node_tainted_with_sym(c, tainted_vars, sym_state))
                        }
                    }
                } else {
                    // Fallback to checking all children
                    node.children.iter().any(|c| self.is_node_tainted_with_sym(c, tainted_vars, sym_state))
                }
            }

            // Handle member expressions like req.body.code, request.query.id
            AstNodeKind::MemberExpression { object, property, .. } => {
                // Build the full path and check if it matches a source pattern
                let full_path = format!("{}.{}", object, property);
                if self.is_source_expression(&full_path) {
                    return true;
                }
                // Also check if the object itself is tainted (for chained access)
                if tainted_vars.contains(object) {
                    return true;
                }
                // Check children for nested member expressions
                node.children.iter().any(|c| self.is_node_tainted_with_sym(c, tainted_vars, sym_state))
            }

            // Handle Python subscript access: map['key'] or arr[index]
            AstNodeKind::Other { node_type } if node_type == "subscript" => {
                // Extract base variable and key from subscript
                // Python subscript structure: base[key] -> children are [base, key] or [base, "[", key, "]"]
                let base_var: Option<String> = node.children.first().map(|n| {
                    if let AstNodeKind::Identifier { name } = &n.kind {
                        name.clone()
                    } else {
                        n.text.trim().to_string()
                    }
                });

                // Extract key - look for string literal in children
                let key = node.children.iter().find_map(|child| {
                    match &child.kind {
                        AstNodeKind::Literal { value: LiteralValue::String(s) } => {
                            Some(s.trim_matches(|c| c == '\'' || c == '"').to_string())
                        }
                        _ if child.text.starts_with('\'') || child.text.starts_with('"') => {
                            let text = child.text.trim_matches(|c| c == '\'' || c == '"');
                            Some(text.to_string())
                        }
                        _ => None
                    }
                });

                if let (Some(base), Some(key)) = (base_var.as_ref(), key) {
                    // We have a specific key access like map['keyA']
                    // ONLY check if this specific key is tainted, not the whole map
                    // This enables strong updates: map['keyA'] = safe_value kills taint
                    let map_key = format!("{}[{}]", base, key);
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG] is_node_tainted: checking subscript '{}', result={}", map_key, tainted_vars.contains(&map_key));

                    // Return the result of checking the specific key only
                    // Do NOT fall through to check the base variable
                    return tainted_vars.contains(&map_key);
                }

                // No specific key (dynamic index) - must conservatively check if base has any tainted values
                if let Some(base) = base_var.as_ref() {
                    if tainted_vars.contains(base) {
                        return true;
                    }
                    // Check if any key in this map is tainted
                    let map_prefix = format!("{}[", base);
                    if tainted_vars.iter().any(|v| v.starts_with(&map_prefix)) {
                        return true;
                    }
                }

                // Fall through to check children
                node.children.iter().any(|c| self.is_node_tainted_with_sym(c, tainted_vars, sym_state))
            }

            AstNodeKind::CallExpression { callee, .. } => {
                // Handle map.get() or list.get() - check if specific key/index is tainted
                if callee.ends_with(".get") {
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG] is_node_tainted: Checking .get() callee='{}'", callee);
                    let parts: Vec<&str> = callee.rsplitn(2, '.').collect();
                    if parts.len() == 2 {
                        let container_var = parts[1];
                        // Find the argument (the key or index)
                        for child in &node.children {
                            if matches!(&child.kind, AstNodeKind::Other { node_type } if node_type == "argument_list") {
                                let args: Vec<&AstNode> = child.children.iter()
                                    .filter(|c| !matches!(&c.kind, AstNodeKind::Other { node_type } if node_type == "(" || node_type == ")" || node_type == ","))
                                    .collect();
                                if !args.is_empty() {
                                    // Try to get as integer index first (for ArrayList.get(index))
                                    let index_opt: Option<usize> = match &args[0].kind {
                                        AstNodeKind::Literal { value: LiteralValue::Number(n) } => {
                                            n.parse::<usize>().ok()
                                        }
                                        _ => {
                                            // Try to evaluate symbolically
                                            match self.evaluate_symbolic(args[0], sym_state) {
                                                SymbolicValue::Concrete(n) if n >= 0 => Some(n as usize),
                                                _ => None,
                                            }
                                        }
                                    };

                                    if let Some(idx) = index_opt {
                                        // This is a list.get(index) - check if specific index is tainted
                                        let list_idx_key = format!("{}@{}", container_var, idx);
                                        #[cfg(debug_assertions)]
                                        eprintln!("[DEBUG]   list.get({}) - checking '{}', tainted={}", idx, list_idx_key, tainted_vars.contains(&list_idx_key));
                                        if tainted_vars.contains(&list_idx_key) {
                                            return true;
                                        }
                                        // Check if any index is tracked for this list (meaning we're tracking it)
                                        let any_tracked = tainted_vars.iter().any(|v| v.starts_with(&format!("{}@", container_var)));
                                        if any_tracked {
                                            // We are tracking this list - return false since this specific index is not tainted
                                            #[cfg(debug_assertions)]
                                            eprintln!("[DEBUG]   List is tracked, index {} not tainted, returning false", idx);
                                            return false;
                                        }
                                    } else {
                                        // Try to get as string key (for Map.get(key))
                                        let key_opt = match &args[0].kind {
                                            AstNodeKind::Literal { value: LiteralValue::String(key) } => {
                                                // Strip quotes if present
                                                Some(key.trim_matches('"').to_string())
                                            }
                                            _ => {
                                                // Try to extract from text
                                                let text = args[0].text.trim();
                                                if text.starts_with('"') && text.ends_with('"') {
                                                    Some(text[1..text.len()-1].to_string())
                                                } else {
                                                    None
                                                }
                                            }
                                        };
                                        if let Some(key) = key_opt {
                                            // Check if this specific key is tainted
                                            let map_key = format!("{}[{}]", container_var, key);
                                            #[cfg(debug_assertions)]
                                            eprintln!("[DEBUG]   map_key='{}', tainted_vars contains? {}", map_key, tainted_vars.contains(&map_key));
                                            if tainted_vars.contains(&map_key) {
                                                return true;
                                            }
                                            // If we tracked this key and it's not tainted, it's safe
                                            // Check if we have any symbolic info about this key
                                            if sym_state.get(&map_key) != SymbolicValue::Unknown {
                                                // We have tracked this key - use our tracked taint status
                                                #[cfg(debug_assertions)]
                                                eprintln!("[DEBUG]   Key was tracked, returning false (not tainted)");
                                                return false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // If we can't determine the key/index, fall through to default behavior
                    }
                }

                // Check if this is a source function
                if self.is_source_function(callee) {
                    return true;
                }

                // Check if the callee has a summary that returns taint
                if let Some(summary) = self.summaries.get(callee) {
                    if summary.generates_taint || summary.returns_taint {
                        return true;
                    }
                }

                // Check if we have the method definition cached for inter-procedural analysis
                // This handles inner class helper methods like Test.doSomething()
                let method_name = callee.split('.').last().unwrap_or(callee);
                if let Some(method) = self.method_cache.get(method_name).cloned() {
                    // Find which argument positions are tainted
                    let mut tainted_param_indices = HashSet::new();
                    for child in &node.children {
                        if matches!(&child.kind, AstNodeKind::Other { node_type } if node_type == "argument_list") {
                            let args: Vec<&AstNode> = child.children.iter()
                                .filter(|c| !matches!(&c.kind, AstNodeKind::Other { node_type } if node_type == "(" || node_type == ")" || node_type == ","))
                                .collect();
                            for (idx, arg) in args.iter().enumerate() {
                                if self.is_node_tainted_with_sym(arg, tainted_vars, sym_state) {
                                    // For Java inner class methods, first param is often HttpServletRequest
                                    // We want param at index 1 for the tainted data
                                    tainted_param_indices.insert(idx);
                                }
                            }
                        }
                    }

                    if !tainted_param_indices.is_empty() {
                        // Use inter-procedural analysis to determine if return is tainted
                        return self.analyze_method_return_taint(&method, &tainted_param_indices);
                    }
                    return false;
                }

                // Check for XPath/SQL quote escaping pattern: .replace("'", "&apos;")
                // This is a common sanitization pattern that prevents injection
                if callee.ends_with(".replace") {
                    if self.is_quote_escaping_pattern(node) {
                        #[cfg(debug_assertions)]
                        eprintln!("[DEBUG]   .replace with quote escaping pattern - treating as sanitizer");
                        return false;
                    }
                }

                // Fallback: If this is NOT a sanitizer and ANY argument is tainted,
                // the return value should also be tainted (taint propagation).
                // This handles cases like URLDecoder.decode(tainted, ...) -> tainted
                if !self.is_sanitizer_function(callee) {
                    for child in &node.children {
                        if self.is_node_tainted_with_sym(child, tainted_vars, sym_state) {
                            return true;
                        }
                    }
                }

                false
            }
            _ => {
                // Check children
                node.children.iter().any(|c| self.is_node_tainted_with_sym(c, tainted_vars, sym_state))
            }
        }
    }

    /// Check if function call has tainted arguments
    /// Uses language handler to determine callee position
    fn has_tainted_arguments(&self, node: &AstNode, tainted_vars: &HashSet<String>, sym_state: &SymbolicState) -> bool {
        // For CallExpression, we only want to check the ARGUMENTS, not the callee
        // Structure is typically: [callee, argument_list] or [callee, "(", arg1, arg2, ..., ")"]
        // The callee is the receiver object (e.g., root.xpath) and should NOT be considered
        // when determining if the arguments are tainted.

        for (idx, child) in node.children.iter().enumerate() {
            // Use language handler to check if this is the callee position
            if self.language_handler.is_callee_position(node, idx) {
                continue;
            }

            if self.is_node_tainted_with_sym(child, tainted_vars, sym_state) {
                #[cfg(debug_assertions)]
                eprintln!("[DEBUG]   Found tainted child: {:?} = '{}'", child.kind, child.text.lines().next().unwrap_or(""));
                return true;
            }
        }
        false
    }

    /// Check if all tainted arguments are sanitized for a specific FlowState.
    /// Returns true if ALL tainted arguments have been sanitized for the given state,
    /// meaning we should NOT create a vulnerability.
    fn are_tainted_args_sanitized_for_state(
        &self,
        node: &AstNode,
        tainted_vars: &HashSet<String>,
        sym_state: &SymbolicState,
        sanitized_for_vars: &HashMap<String, HashSet<FlowState>>,
        sink_state: &FlowState,
    ) -> bool {
        let mut found_unsanitized_tainted = false;

        for (idx, child) in node.children.iter().enumerate() {
            // Skip callee position
            if self.language_handler.is_callee_position(node, idx) {
                continue;
            }

            // Check if this argument is tainted
            if self.is_node_tainted_with_sym(child, tainted_vars, sym_state) {
                // Get the variable name from the argument
                let var_name = self.extract_variable_name(child);

                if let Some(name) = var_name {
                    // Check if this variable is sanitized for the sink's FlowState
                    if let Some(sanitized_states) = sanitized_for_vars.get(&name) {
                        // Check if sanitized for this specific state or Generic (universal)
                        if sanitized_states.contains(sink_state) || sanitized_states.contains(&FlowState::Generic) {
                            #[cfg(debug_assertions)]
                            eprintln!("[DEBUG]   Variable '{}' is sanitized for {:?}", name, sink_state);
                            continue; // This tainted var is sanitized, check others
                        }
                    }
                    // Variable is tainted but NOT sanitized for this sink
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG]   Variable '{}' is tainted but NOT sanitized for {:?}", name, sink_state);
                    found_unsanitized_tainted = true;
                } else {
                    // Can't determine variable name, assume not sanitized
                    found_unsanitized_tainted = true;
                }
            }
        }

        // Return true only if we found no unsanitized tainted arguments
        !found_unsanitized_tainted
    }

    /// Extract variable name from a node for sanitization checking
    fn extract_variable_name(&self, node: &AstNode) -> Option<String> {
        match &node.kind {
            AstNodeKind::Identifier { name } => Some(name.clone()),
            AstNodeKind::MemberExpression { .. } => {
                // For member expressions like obj.field, return the whole thing
                Some(node.text.trim().to_string())
            }
            _ => {
                // Try to find an identifier in children
                for child in &node.children {
                    if let AstNodeKind::Identifier { name } = &child.kind {
                        return Some(name.clone());
                    }
                }
                // Last resort: use the text
                let text = node.text.trim();
                if !text.is_empty() && text.len() < 100 {
                    Some(text.to_string())
                } else {
                    None
                }
            }
        }
    }

    // Helper methods

    fn find_function_node<'a>(&self, ast: &'a AstNode, func_name: &str) -> Option<&'a AstNode> {
        match &ast.kind {
            AstNodeKind::FunctionDeclaration { name, .. } if name == func_name => {
                return Some(ast);
            }
            AstNodeKind::MethodDeclaration { name, .. } => {
                // Handle both "ClassName.methodName" and just "methodName"
                if func_name.ends_with(&format!(".{}", name)) || name == func_name {
                    return Some(ast);
                }
            }
            _ => {}
        }

        for child in &ast.children {
            if let Some(found) = self.find_function_node(child, func_name) {
                return Some(found);
            }
        }

        None
    }

    fn extract_parameters(&self, func: &AstNode) -> Vec<String> {
        match &func.kind {
            AstNodeKind::FunctionDeclaration { parameters, .. } => {
                parameters.iter().map(|p| p.name.clone()).collect()
            }
            AstNodeKind::MethodDeclaration { parameters, .. } => {
                parameters.iter().map(|p| p.name.clone()).collect()
            }
            _ => vec![],
        }
    }

    /// Analyze a method to determine if it returns tainted data given tainted parameters.
    /// This implements basic inter-procedural taint analysis for helper methods.
    fn analyze_method_return_taint(
        &self,
        method: &AstNode,
        tainted_param_indices: &HashSet<usize>,
    ) -> bool {
        let params = self.extract_parameters(method);

        // Build initial tainted set from tainted parameter indices
        let mut local_tainted: HashSet<String> = HashSet::new();
        let mut local_sym_state = SymbolicState::new();
        let mut local_list_sizes: HashMap<String, usize> = HashMap::new();

        for idx in tainted_param_indices {
            if let Some(param_name) = params.get(*idx) {
                local_tainted.insert(param_name.clone());
            }
        }

        // Analyze the method body to track taint flow
        let mut vulnerabilities = Vec::new();
        let mut local_path_sanitized: HashSet<String> = HashSet::new();
        let mut local_sanitized_for: HashMap<String, HashSet<FlowState>> = HashMap::new();
        for child in &method.children {
            self.track_taint_in_ast_with_depth(
                child, &mut local_tainted, &mut vulnerabilities, 0, 0, &mut local_sym_state, &mut local_list_sizes, &mut local_path_sanitized, &mut local_sanitized_for
            );
        }

        // Find return statements and check if returned value is tainted
        self.find_return_taint(method, &local_tainted, &local_sym_state)
    }

    /// Check if any return statement in the method returns tainted data
    fn find_return_taint(&self, node: &AstNode, tainted_vars: &HashSet<String>, sym_state: &SymbolicState) -> bool {
        match &node.kind {
            AstNodeKind::ReturnStatement => {
                // Check if the returned expression is tainted
                #[cfg(debug_assertions)]
                eprintln!("[DEBUG] find_return_taint: ReturnStatement found, checking children");
                for child in &node.children {
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG]   Checking return child: {:?} = '{}'", child.kind, child.text.lines().next().unwrap_or(""));
                    let is_tainted = self.is_node_tainted_with_sym(child, tainted_vars, sym_state);
                    #[cfg(debug_assertions)]
                    eprintln!("[DEBUG]   is_tainted = {}, tainted_vars = {:?}", is_tainted, tainted_vars);
                    if is_tainted {
                        return true;
                    }
                }
                false
            }
            _ => {
                // Recurse into children
                for child in &node.children {
                    if self.find_return_taint(child, tainted_vars, sym_state) {
                        return true;
                    }
                }
                false
            }
        }
    }

    fn extract_identifier(&self, node: &AstNode) -> Option<String> {
        match &node.kind {
            AstNodeKind::Identifier { name } => Some(name.clone()),
            _ => {
                for child in &node.children {
                    if let Some(id) = self.extract_identifier(child) {
                        return Some(id);
                    }
                }
                None
            }
        }
    }

    fn is_source_function(&self, name: &str) -> bool {
        // Check flow registry first
        if let Some(summary) = self.flow_registry.get(name) {
            if summary.is_source {
                return true;
            }
        }
        // Also check by just the method name (e.g., "getParameter" from "request.getParameter")
        let method_name = name.split('.').last().unwrap_or(name);
        if let Some(summary) = self.flow_registry.get(method_name) {
            if summary.is_source {
                return true;
            }
        }

        // Check for cookie method calls that return user input
        // More conservative: only match when the FULL callee looks cookie-related
        //
        // TODO: Refactor to language_handler.rs - this is Java-specific source detection
        // that should be delegated to LanguageTaintHandler::is_contextual_source() to keep
        // the core algorithm language-agnostic.
        let name_lower = name.to_lowercase();
        let method_lower = method_name.to_lowercase();

        // Match .getValue()/.getName() only if receiver looks like a cookie variable
        // Common patterns: cookie.getValue(), theCookie.getValue(), c.getValue(), etc.
        if (method_lower == "getvalue" || method_lower == "getname" || method_lower == "getcomment") {
            // Check if the receiver name suggests it's a cookie
            let receiver = name.rsplitn(2, '.').nth(1).unwrap_or("");
            let receiver_lower = receiver.to_lowercase();
            if receiver_lower.contains("cookie")
                || receiver_lower == "c"  // Common single-letter variable in cookie loops
                || (receiver_lower.starts_with("the") && receiver_lower.contains("cook"))
            {
                #[cfg(debug_assertions)]
                eprintln!("[DEBUG] is_source_function: '{}' matched as cookie method (receiver='{}')", name, receiver);
                return true;
            }
        }

        // Match headers.nextElement() patterns
        if method_lower == "nextelement" {
            // Check if the receiver looks like a headers enumeration
            let receiver = name.rsplitn(2, '.').nth(1).unwrap_or("");
            let receiver_lower = receiver.to_lowercase();
            if receiver_lower.contains("header") {
                #[cfg(debug_assertions)]
                eprintln!("[DEBUG] is_source_function: '{}' matched as headers enumeration", name);
                return true;
            }
        }

        // Fall back to legacy sources
        let result = self.sources.iter().any(|s| {
            let source_lower = s.name.to_lowercase();
            let matches = name_lower.contains(&source_lower) || source_lower.contains(&name_lower);
            #[cfg(debug_assertions)]
            if matches {
                eprintln!("[DEBUG] is_source_function: '{}' matched source '{}' (name_contains_src={}, src_contains_name={})",
                    name, s.name, name_lower.contains(&source_lower), source_lower.contains(&name_lower));
            }
            matches
        });
        result
    }

    /// Check if a member expression path matches a source pattern
    /// Handles patterns like "req.body", "request.query", "req.body.code"
    fn is_source_expression(&self, path: &str) -> bool {
        // Check flow registry
        if let Some(summary) = self.flow_registry.get(path) {
            if summary.is_source {
                return true;
            }
        }

        let path_lower = path.to_lowercase();
        self.sources.iter().any(|s| {
            let source_lower = s.name.to_lowercase();
            // Check if path starts with or contains the source pattern
            // e.g., "req.body.code" matches "req.body" source
            path_lower.starts_with(&source_lower)
                || path_lower.contains(&source_lower)
                || source_lower.contains(&path_lower)
        })
    }

    fn is_sink_function(&self, name: &str) -> bool {
        // Check flow registry first
        if let Some(summary) = self.flow_registry.get(name) {
            if summary.is_sink.is_some() {
                return true;
            }
        }
        // Also check by just the method name
        let method_name = name.split('.').last().unwrap_or(name);
        if let Some(summary) = self.flow_registry.get(method_name) {
            if summary.is_sink.is_some() {
                return true;
            }
        }

        // Common method names that should NOT match by method name alone
        // These are too generic and cause false positives when matching specific sinks
        // Note: Do NOT add "digest" here - needed for hash detection (MessageDigest.digest)
        let common_methods = [
            "get", "set", "put", "add", "remove", "contains", "size", "length",
            "open", "close", "read", "write", "run", "call", "send", "recv",
            "parse", "format", "str", "int", "float", "list", "dict",
            "append", // Common non-security method
            // SQL-related names that are too generic without class context
            // Note: "execute" is NOT here - Statement.execute() is distinctive enough
            "query", "update", "insert", "delete", "select",
        ];
        let method_name_lower = method_name.to_lowercase();
        let is_common_method = common_methods.contains(&method_name_lower.as_str());

        // Fall back to legacy sinks
        let name_lower = name.to_lowercase();
        self.sinks.iter().any(|s| {
            let sink_lower = s.name.to_lowercase();
            let sink_method = s.name.split('.').last().unwrap_or(&s.name).to_lowercase();

            // Exact match (most reliable)
            if name_lower == sink_lower {
                return true;
            }

            // Match by method name ending with sink method
            // e.g., "executeQuery" ends with "query" sink, "doQuery" ends with "query"
            // But only if the sink method is not a common method
            if !is_common_method && sink_method.len() >= 4 {
                // Check if the method name ends with the sink method name
                // This handles cases like "doExecute" matching "execute" sink
                if method_name_lower.ends_with(&sink_method) {
                    return true;
                }
                // Check if the method name starts with the sink method name
                // This handles cases like "executeQuery" matching "execute" sink
                if method_name_lower.starts_with(&sink_method) {
                    return true;
                }
            }

            // Match by method name only if it's not a common method
            if !is_common_method && method_name_lower == sink_method {
                return true;
            }

            false
        })
    }

    fn is_sanitizer_function(&self, name: &str) -> bool {
        // Check flow registry first
        if let Some(summary) = self.flow_registry.get(name) {
            if summary.is_sanitizer {
                return true;
            }
        }
        // Also check by just the method name
        let method_name = name.split('.').last().unwrap_or(name);
        if let Some(summary) = self.flow_registry.get(method_name) {
            if summary.is_sanitizer {
                return true;
            }
        }

        // Fall back to legacy sanitizers
        let name_lower = name.to_lowercase();
        self.sanitizers.iter().any(|s| {
            let sanitizer_lower = s.to_lowercase();
            name_lower.contains(&sanitizer_lower)
        })
    }

    /// Get the FlowStates that a sanitizer function is effective for.
    /// This enables context-specific sanitization - escapeHtml sanitizes HTML but NOT SQL.
    /// Returns None if the function is not a sanitizer, Some(empty) for universal sanitizers,
    /// or Some(states) for context-specific sanitizers.
    fn get_sanitizer_flow_states(&self, name: &str) -> Option<HashSet<FlowState>> {
        let name_lower = name.to_lowercase();

        // HTML/XSS sanitizers
        if name_lower.contains("escapehtml") || name_lower.contains("htmlescape")
            || name_lower.contains("htmlspecialchars") || name_lower.contains("htmlentities")
            || name_lower.contains("encodeforhtml") || name_lower.contains("sanitizehtml")
            || (name_lower.contains("escape") && name_lower.contains("html")) {
            let mut states = HashSet::new();
            states.insert(FlowState::Html);
            return Some(states);
        }

        // SQL sanitizers
        if name_lower.contains("escapesql") || name_lower.contains("encodeforsql")
            || name_lower.contains("sanitizesql") || name_lower.contains("quotesql")
            || name_lower.contains("preparedstatement.set") {
            let mut states = HashSet::new();
            states.insert(FlowState::Sql);
            return Some(states);
        }

        // Command/Shell sanitizers
        if name_lower.contains("escapeshell") || name_lower.contains("shellwords")
            || name_lower.contains("escapejava") || name_lower.contains("encodeforcommand")
            || name_lower.contains("processbuilder") {
            let mut states = HashSet::new();
            states.insert(FlowState::Shell);
            return Some(states);
        }

        // Path traversal sanitizers
        if name_lower.contains("canonicalpath") || name_lower.contains("normalize")
            || name_lower.contains("realpath") || name_lower.contains("escapepath") {
            let mut states = HashSet::new();
            states.insert(FlowState::Path);
            return Some(states);
        }

        // LDAP sanitizers
        if name_lower.contains("escapeldap") || name_lower.contains("encodeforldn")
            || name_lower.contains("encodefordistinguishedname") {
            let mut states = HashSet::new();
            states.insert(FlowState::Ldap);
            return Some(states);
        }

        // XML/XPath sanitizers
        if name_lower.contains("escapexml") || name_lower.contains("encodeforxml")
            || name_lower.contains("escapexpath") {
            let mut states = HashSet::new();
            states.insert(FlowState::Xml);
            return Some(states);
        }

        // Type conversion functions are universal sanitizers
        // Converting to a numeric type makes injection impossible
        // Java: Integer.parseInt, Long.parseLong, Double.parseDouble, etc.
        // Python: int(), float(), str() when used for validation
        // JavaScript: parseInt(), parseFloat(), Number()
        // Go: strconv.Atoi, strconv.ParseInt, strconv.ParseFloat
        // Ruby: to_i, to_f
        if name_lower.contains("parseint") || name_lower.contains("parselong")
            || name_lower.contains("parsedouble") || name_lower.contains("parsefloat")
            || name_lower.contains("parseBoolean")
            || name_lower == "int" || name_lower == "float" || name_lower == "long" || name_lower == "double"
            || name_lower.contains("atoi") || name_lower.contains("atol") || name_lower.contains("atof")
            || name_lower == "number" || name_lower == "boolean"
            || name_lower == "to_i" || name_lower == "to_f" || name_lower == "to_s"
            || name_lower.contains("strconv.atoi") || name_lower.contains("strconv.parseint")
            || name_lower.contains("strconv.parsefloat") || name_lower.contains("strconv.parsebool")
            || name_lower.contains("valueof") {
            // Type conversions are universal sanitizers - they make injection impossible
            return Some(HashSet::new());
        }

        // Universal sanitizers (validation, encoding functions that sanitize all types)
        if name_lower.contains("validate") || name_lower.contains("isvalid")
            || name_lower.contains("whitelist") || name_lower.contains("allowlist") {
            // Universal sanitizers use empty set to indicate all states
            return Some(HashSet::new());
        }

        // Check if it's a sanitizer via is_sanitizer_function but not context-specific
        if self.is_sanitizer_function(name) {
            // Generic sanitizer - sanitizes all states
            return Some(HashSet::new());
        }

        // Check YAML config for sanitizers defined in MaD format
        if let Some(states) = get_yaml_sanitizer_flow_states(self.language_handler.language(), name) {
            return Some(states);
        }

        None
    }

    /// Check if a .replace() call is a quote escaping pattern that sanitizes injection
    /// Examples: .replace("'", "&apos;"), .replace("'", "''"), .replace("\"", "&quot;")
    fn is_quote_escaping_pattern(&self, node: &AstNode) -> bool {
        let text = &node.text;

        // Check for XPath/XML quote escaping: .replace("'", "&apos;") or .replace('\'', '&apos;')
        if text.contains("&apos;") || text.contains("&quot;") {
            return true;
        }

        // Check for SQL quote doubling: .replace("'", "''")
        if text.contains("''") {
            return true;
        }

        // Check for backslash escaping: .replace("'", "\\'")
        if text.contains("\\\\'") || text.contains("\\\\\"") {
            return true;
        }

        false
    }

    /// Detect validation guard patterns in if statements.
    /// Returns Some(var_name) if the condition is checking for a dangerous pattern in a variable
    /// and the then-branch contains an early return/exit.
    /// Pattern: `if '<dangerous_pattern>' in var: return`
    fn detect_validation_guard(&self, condition: &AstNode, then_branch: &AstNode) -> Option<String> {
        // First check if the then-branch has an early return
        if !self.has_early_return(then_branch) {
            return None;
        }

        // Check for patterns like:
        // - Python: if '<dangerous>' in var
        // - Java: if (str.contains("<dangerous>"))
        // The dangerous patterns we care about:
        // - '../' or '..' for path traversal
        // - "'" for SQL/XPath injection
        // - '<' or '>' for XSS

        let condition_text = condition.text.to_lowercase();

        // Python pattern: 'pattern' in var or "pattern" in var
        // Also handles: if '../' in bar, if '\'' in bar
        if condition_text.contains(" in ") {
            // Extract the variable being checked
            // Pattern: <something> in <var>
            if let Some(in_pos) = condition_text.find(" in ") {
                let after_in = &condition_text[in_pos + 4..];
                // Extract variable name (might have trailing : or other chars)
                let var_name: String = after_in
                    .chars()
                    .take_while(|c| c.is_alphanumeric() || *c == '_')
                    .collect();

                if !var_name.is_empty() {
                    // Check if the pattern being searched is a dangerous one
                    let before_in = &condition_text[..in_pos];
                    let is_path_guard = before_in.contains("../") || before_in.contains("..");
                    let is_injection_guard = before_in.contains("'") || before_in.contains("\"");
                    let is_xss_guard = before_in.contains("<") || before_in.contains(">");

                    if is_path_guard || is_injection_guard || is_xss_guard {
                        return Some(var_name);
                    }
                }
            }
        }

        // Java pattern: str.contains("pattern") or var.indexOf("pattern") >= 0
        if condition_text.contains(".contains(") || condition_text.contains(".indexof(") {
            // Extract the object the method is called on
            if let Some(dot_pos) = condition_text.find('.') {
                let var_name: String = condition_text[..dot_pos]
                    .chars()
                    .rev()
                    .take_while(|c| c.is_alphanumeric() || *c == '_')
                    .collect::<String>()
                    .chars()
                    .rev()
                    .collect();

                if !var_name.is_empty() {
                    // Check for dangerous patterns in the argument
                    let is_path_guard = condition_text.contains("../") || condition_text.contains("..");
                    let is_injection_guard = condition_text.contains("'") || condition_text.contains("\\\"");

                    if is_path_guard || is_injection_guard {
                        return Some(var_name);
                    }
                }
            }
        }

        // Python: var.startswith('safe') pattern - inverse guard
        // If startswith check passes AND doesn't return, the var is safe
        // But this is opposite - we handle the case where startswith fails
        // For now, skip this more complex pattern

        None
    }

    /// Check if a node or any of its descendants contains a return statement
    fn has_early_return(&self, node: &AstNode) -> bool {
        match &node.kind {
            AstNodeKind::ReturnStatement => true,
            AstNodeKind::ThrowStatement { .. } => true,
            // Also consider raise in Python (represented as CallExpression to "raise")
            AstNodeKind::CallExpression { callee, .. } if callee == "raise" => true,
            _ => {
                // Check children
                node.children.iter().any(|c| self.has_early_return(c))
            }
        }
    }

    fn find_sink_by_name(&self, name: &str) -> Option<&TaintSink> {
        let name_lower = name.to_lowercase();
        // Extract just the method name (after last .)
        let method_name = name.split('.').last().unwrap_or(name).to_lowercase();

        // Common method names that should NOT match by method name alone
        // These require class/object context to match
        // Also includes method names that are too short/generic (query, update, etc.)
        let common_methods = [
            "get", "set", "put", "add", "remove", "contains", "size", "length",
            "open", "close", "read", "write", "run", "call", "send", "recv",
            "parse", "format", "str", "int", "float", "list", "dict",
            // SQL-related names that are too generic without class context
            // Note: "execute" is NOT here - Statement.execute() is distinctive enough
            "query", "update", "insert", "delete", "select",
        ];
        let is_common_method = common_methods.contains(&method_name.as_str());

        // Also check if the sink would match via substring and that's problematic
        // e.g., "open" should not match "os.popen" just because popen contains open

        let result = self.sinks.iter().find(|s| {
            let sink_lower = s.name.to_lowercase();
            let sink_method = s.name.split('.').last().unwrap_or(&s.name).to_lowercase();

            // Exact match (most reliable)
            if name_lower == sink_lower {
                return true;
            }

            // Match by method name ending or starting with sink method
            // e.g., "doQuery" ends with "query" sink, "executeQuery" starts with "execute"
            // But only if the sink method is not a common method
            if !is_common_method && sink_method.len() >= 4 {
                // Check if the method name ends with the sink method name
                if method_name.ends_with(&sink_method) {
                    return true;
                }
                // Check if the method name starts with the sink method name
                if method_name.starts_with(&sink_method) {
                    return true;
                }
            }

            // Match by method name only if it's not a common method
            // (to avoid map.get matching Paths.get)
            if !is_common_method && method_name == sink_method {
                return true;
            }

            false
        });

        #[cfg(debug_assertions)]
        if result.is_none() && self.is_sink_function(name) {
            eprintln!("[DEBUG] find_sink_by_name('{}') = None, but is_sink_function=true", name);
        }

        result
    }

    /// Configure default sources
    pub fn with_default_sources(mut self) -> Self {
        let user_input_sources = vec![
            "request.body", "request.query", "request.params",
            "req.body", "req.query", "req.params",
            "getUserInput", "getInput", "readInput",
            "input", "stdin", "argv", "os.Args",
        ];

        for source_name in user_input_sources {
            self.sources.push(TaintSource {
                name: source_name.to_string(),
                kind: TaintSourceKind::UserInput,
                node_id: 0,
            });
        }

        self
    }

    /// Configure default sinks
    pub fn with_default_sinks(mut self) -> Self {
        // Note: Generic names like "query", "update" are NOT included here
        // because they cause false positives. These should be matched via YAML configs
        // with proper class/package context (e.g., JdbcTemplate.query)
        // However, "execute" is included because Statement.execute() is common and distinctive enough
        let sql_sinks = vec!["execute", "executeQuery", "executeUpdate", "prepareStatement", "prepareCall",
                             "queryForObject", "queryForList", "queryForMap", "createQuery",
                             "createNativeQuery", "nativeQuery"];
        for sink_name in sql_sinks {
            self.sinks.push(TaintSink {
                name: sink_name.to_string(),
                kind: TaintSinkKind::SqlQuery,
                node_id: 0,
            });
        }

        let cmd_sinks = vec!["exec", "spawn", "system", "popen", "os.system"];
        for sink_name in cmd_sinks {
            self.sinks.push(TaintSink {
                name: sink_name.to_string(),
                kind: TaintSinkKind::CommandExecution,
                node_id: 0,
            });
        }

        self
    }

    /// Configure default sanitizers
    pub fn with_default_sanitizers(mut self) -> Self {
        let sanitizers = vec![
            "escape", "sanitize", "validate",
            "escapeHtml", "escapeSql", "clean", "filter",
        ];

        for sanitizer in sanitizers {
            self.sanitizers.insert(sanitizer.to_string());
        }

        self
    }

    /// Configure taint analysis for a specific language
    ///
    /// This method replaces the default configuration with language-specific
    /// taint sources, sinks, and sanitizers appropriate for the target language.
    pub fn for_language(mut self, language: gittera_parser::Language) -> Self {
        use crate::taint_config::LanguageTaintConfig;

        let config = LanguageTaintConfig::for_language(language);

        // Replace sources, sinks, and sanitizers with language-specific ones
        self.sources = config.sources;
        self.sinks = config.sinks;
        self.sanitizers = config.sanitizers.into_iter().collect();

        // Update the language handler to match the language
        self.language_handler = get_handler_for_language(language);

        self
    }
}

impl Default for InterproceduralTaintAnalysis {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use gittera_parser::ast::{Location, Span};

    fn test_location() -> Location {
        Location {
            file_path: "test.rs".to_string(),
            span: Span {
                start_line: 1,
                start_column: 0,
                end_line: 1,
                end_column: 10,
                start_byte: 0,
                end_byte: 10,
            },
        }
    }

    #[test]
    fn test_function_summary_creation() {
        let summary = FunctionTaintSummary::new("test_func".to_string());
        assert_eq!(summary.name, "test_func");
        assert!(!summary.returns_taint);
        assert!(!summary.generates_taint);
    }

    #[test]
    fn test_source_detection() {
        let mut analysis = InterproceduralTaintAnalysis::new()
            .with_default_sources();

        assert!(analysis.is_source_function("getUserInput"));
        assert!(analysis.is_source_function("getInput"));
        assert!(!analysis.is_source_function("normalFunction"));
    }

    #[test]
    fn test_sink_detection() {
        let mut analysis = InterproceduralTaintAnalysis::new()
            .with_default_sinks();

        assert!(analysis.is_sink_function("executeQuery"));
        // "query" alone is too generic - should NOT match without class context
        assert!(!analysis.is_sink_function("query"));
        // But specific methods like queryForObject should still match
        assert!(analysis.is_sink_function("queryForObject"));
        assert!(!analysis.is_sink_function("normalFunction"));
        // Variable names containing "query" should NOT match as sinks
        assert!(!analysis.is_sink_function("queryString.indexOf"));
    }

    #[test]
    fn test_sanitizer_detection() {
        let mut analysis = InterproceduralTaintAnalysis::new()
            .with_default_sanitizers();

        assert!(analysis.is_sanitizer_function("sanitize"));
        assert!(analysis.is_sanitizer_function("escapeHtml"));
        assert!(!analysis.is_sanitizer_function("normalFunction"));
    }

    #[test]
    fn test_parameter_extraction() {
        let analysis = InterproceduralTaintAnalysis::new();

        let func = AstNode::new(
            1,
            AstNodeKind::FunctionDeclaration {
                name: "test".to_string(),
                parameters: vec![
                    gittera_parser::Parameter {
                        name: "a".to_string(),
                        param_type: None,
                        default_value: None,
                        is_optional: false,
                        is_rest: false,
                    },
                    gittera_parser::Parameter {
                        name: "b".to_string(),
                        param_type: None,
                        default_value: None,
                        is_optional: false,
                        is_rest: false,
                    },
                ],
                return_type: None,
                is_async: false,
                is_generator: false,
            },
            test_location(),
            "fn test(a, b) {}".to_string(),
        );

        let params = analysis.extract_parameters(&func);
        assert_eq!(params, vec!["a", "b"]);
    }

    #[test]
    fn test_strong_update_kills_taint_at_top_level() {
        // Test that taint is killed when a variable is reassigned at top level
        // (not inside a branch)
        //
        // x = getUserInput();  // x is tainted
        // x = "safe";          // STRONG UPDATE: x should no longer be tainted
        // sink(x);             // Should NOT be a vulnerability
        let analysis = InterproceduralTaintAnalysis::new()
            .with_default_sources()
            .with_default_sinks();

        let mut tainted_vars: HashSet<String> = HashSet::new();
        tainted_vars.insert("x".to_string());

        // Simulate: x = "safe" (clean assignment at branch_depth 0)
        let clean_rhs = AstNode::new(
            10,
            AstNodeKind::Literal {
                value: gittera_parser::ast::LiteralValue::String("safe".to_string()),
            },
            test_location(),
            "\"safe\"".to_string(),
        );

        let lhs = AstNode::new(
            11,
            AstNodeKind::Identifier { name: "x".to_string() },
            test_location(),
            "x".to_string(),
        );

        let mut assignment = AstNode::new(
            12,
            AstNodeKind::AssignmentExpression { operator: "=".to_string() },
            test_location(),
            "x = \"safe\"".to_string(),
        );
        assignment.children.push(lhs);
        assignment.children.push(clean_rhs);

        let mut vulnerabilities = Vec::new();
        let mut sym_state = SymbolicState::new();
        let mut list_sizes: HashMap<String, usize> = HashMap::new();
        let mut path_sanitized_vars: HashSet<String> = HashSet::new();
        let mut sanitized_for_vars: HashMap<String, HashSet<FlowState>> = HashMap::new();

        // Process at branch_depth 0 - should do strong update
        analysis.track_taint_in_ast_with_depth(&assignment, &mut tainted_vars, &mut vulnerabilities, 0, 0, &mut sym_state, &mut list_sizes, &mut path_sanitized_vars, &mut sanitized_for_vars);

        // x should no longer be tainted
        assert!(!tainted_vars.contains("x"), "Strong update should kill taint for x");
    }

    #[test]
    fn test_no_strong_update_inside_branch() {
        // Test that taint is NOT killed when inside a branch
        //
        // x = getUserInput();   // x is tainted
        // if (cond) {
        //   x = "safe";         // NO strong update - branch_depth > 0
        // }
        // sink(x);              // SHOULD be a vulnerability (x might still be tainted)
        let analysis = InterproceduralTaintAnalysis::new()
            .with_default_sources()
            .with_default_sinks();

        let mut tainted_vars: HashSet<String> = HashSet::new();
        tainted_vars.insert("x".to_string());

        // Simulate: x = "safe" inside a branch (branch_depth > 0)
        let clean_rhs = AstNode::new(
            20,
            AstNodeKind::Literal {
                value: gittera_parser::ast::LiteralValue::String("safe".to_string()),
            },
            test_location(),
            "\"safe\"".to_string(),
        );

        let lhs = AstNode::new(
            21,
            AstNodeKind::Identifier { name: "x".to_string() },
            test_location(),
            "x".to_string(),
        );

        let mut assignment = AstNode::new(
            22,
            AstNodeKind::AssignmentExpression { operator: "=".to_string() },
            test_location(),
            "x = \"safe\"".to_string(),
        );
        assignment.children.push(lhs);
        assignment.children.push(clean_rhs);

        let mut vulnerabilities = Vec::new();
        let mut sym_state = SymbolicState::new();
        let mut list_sizes: HashMap<String, usize> = HashMap::new();
        let mut path_sanitized_vars: HashSet<String> = HashSet::new();
        let mut sanitized_for_vars: HashMap<String, HashSet<FlowState>> = HashMap::new();

        // Process at branch_depth 1 - should NOT do strong update
        analysis.track_taint_in_ast_with_depth(&assignment, &mut tainted_vars, &mut vulnerabilities, 1, 0, &mut sym_state, &mut list_sizes, &mut path_sanitized_vars, &mut sanitized_for_vars);

        // x should STILL be tainted (conservative behavior)
        assert!(tainted_vars.contains("x"), "Should NOT do strong update inside a branch");
    }
}
