//! Interprocedural Taint Analysis - Track taint across function boundaries
//!
//! This module extends the intraprocedural taint analysis to track taint
//! through function calls using the call graph.

use crate::call_graph::CallGraph;
use crate::taint::{TaintAnalysisResult, TaintSink, TaintSource, TaintSourceKind, TaintValue, TaintVulnerability, Severity, TaintSinkKind};
use kodecd_parser::ast::{AstNode, AstNodeKind};
use std::collections::{HashMap, HashSet};

/// Summary of taint behavior for a function
#[derive(Debug, Clone)]
pub struct FunctionTaintSummary {
    /// Function name
    pub name: String,
    /// Which parameters are tainted in the summary
    pub tainted_params: HashSet<usize>,
    /// Whether the return value is tainted
    pub returns_taint: bool,
    /// What sanitization this function performs
    pub sanitizes_params: HashSet<usize>,
    /// Sources generated by this function
    pub generates_taint: bool,
}

impl FunctionTaintSummary {
    pub fn new(name: String) -> Self {
        Self {
            name,
            tainted_params: HashSet::new(),
            returns_taint: false,
            sanitizes_params: HashSet::new(),
            generates_taint: false,
        }
    }
}

/// Interprocedural taint analysis engine
pub struct InterproceduralTaintAnalysis {
    sources: Vec<TaintSource>,
    sinks: Vec<TaintSink>,
    sanitizers: HashSet<String>,
    /// Function summaries computed during analysis
    summaries: HashMap<String, FunctionTaintSummary>,
}

impl InterproceduralTaintAnalysis {
    pub fn new() -> Self {
        Self {
            sources: Vec::new(),
            sinks: Vec::new(),
            sanitizers: HashSet::new(),
            summaries: HashMap::new(),
        }
    }

    pub fn add_source(&mut self, source: TaintSource) {
        self.sources.push(source);
    }

    pub fn add_sink(&mut self, sink: TaintSink) {
        self.sinks.push(sink);
    }

    pub fn add_sanitizer(&mut self, name: String) {
        self.sanitizers.insert(name);
    }

    /// Analyze the program with interprocedural taint tracking
    pub fn analyze(
        &mut self,
        ast: &AstNode,
        call_graph: &CallGraph,
    ) -> TaintAnalysisResult {
        // Phase 1: Build function summaries in topological order (bottom-up)
        self.build_summaries(call_graph, ast);

        // Phase 2: Find vulnerabilities using summaries
        self.find_vulnerabilities_interprocedural(ast, call_graph)
    }

    /// Build function summaries in bottom-up order
    fn build_summaries(
        &mut self,
        call_graph: &CallGraph,
        ast: &AstNode,
    ) {
        // Get topological order (callees before callers)
        let order = match call_graph.topological_sort() {
            Some(order) => order,
            None => {
                // Cycle detected - fall back to arbitrary order
                call_graph.nodes().map(|n| n.name.clone()).collect()
            }
        };

        // Process functions in order
        for func_name in order {
            let summary = self.compute_summary(&func_name, ast, call_graph);
            self.summaries.insert(func_name, summary);
        }
    }

    /// Compute taint summary for a single function
    fn compute_summary(
        &self,
        func_name: &str,
        ast: &AstNode,
        call_graph: &CallGraph,
    ) -> FunctionTaintSummary {
        let mut summary = FunctionTaintSummary::new(func_name.to_string());

        // Find the function AST node
        let func_node = self.find_function_node(ast, func_name);
        if func_node.is_none() {
            return summary;
        }

        // Check if this function is a source
        if self.is_source_function(func_name) {
            summary.generates_taint = true;
            summary.returns_taint = true;
            return summary;
        }

        // Check if this function is a sanitizer
        if self.is_sanitizer_function(func_name) {
            summary.sanitizes_params.insert(0); // Sanitizes first parameter
            return summary;
        }

        // Analyze function body for taint flow
        if let Some(func) = func_node {
            self.analyze_function_body(func, &mut summary, call_graph);
        }

        summary
    }

    /// Analyze a function body to determine taint behavior
    fn analyze_function_body(
        &self,
        func: &AstNode,
        summary: &mut FunctionTaintSummary,
        call_graph: &CallGraph,
    ) {
        // Extract parameters
        let params = self.extract_parameters(func);

        // Look for:
        // 1. Calls to sources -> generates_taint = true, returns_taint = true
        // 2. Return statements with parameters -> mark those params as contributing to return
        // 3. Calls to other functions -> use their summaries

        self.visit_for_taint_behavior(func, summary, &params, call_graph);
    }

    /// Visit nodes to determine taint behavior
    fn visit_for_taint_behavior(
        &self,
        node: &AstNode,
        summary: &mut FunctionTaintSummary,
        params: &[String],
        call_graph: &CallGraph,
    ) {
        match &node.kind {
            AstNodeKind::CallExpression { callee, .. } => {
                // Check if calling a source
                if self.is_source_function(callee) {
                    summary.generates_taint = true;
                    // If this call result might be returned, mark returns_taint
                    // For now, conservatively assume it might be
                    summary.returns_taint = true;
                } else if let Some(callee_summary) = self.summaries.get(callee) {
                    // Use summary of called function
                    if callee_summary.returns_taint {
                        summary.returns_taint = true;
                    }
                    if callee_summary.generates_taint {
                        summary.generates_taint = true;
                    }
                }
            }

            AstNodeKind::ReturnStatement => {
                // Check if returning a parameter or tainted value
                // For simplicity, check if any identifier in return is a parameter
                for child in &node.children {
                    if let Some(name) = self.extract_identifier(child) {
                        if let Some(param_idx) = params.iter().position(|p| p == &name) {
                            summary.tainted_params.insert(param_idx);
                            summary.returns_taint = true;
                        }
                    }
                }
            }

            _ => {}
        }

        // Recursively visit children
        for child in &node.children {
            self.visit_for_taint_behavior(child, summary, params, call_graph);
        }
    }

    /// Find vulnerabilities using interprocedural analysis
    fn find_vulnerabilities_interprocedural(
        &self,
        ast: &AstNode,
        _call_graph: &CallGraph,
    ) -> TaintAnalysisResult {
        let mut vulnerabilities = Vec::new();

        // Track taint through the program using summaries
        let mut tainted_vars: HashSet<String> = HashSet::new();

        // Traverse AST and track taint
        self.track_taint_in_ast(ast, &mut tainted_vars, &mut vulnerabilities);

        TaintAnalysisResult { vulnerabilities }
    }

    /// Track taint through AST using function summaries
    fn track_taint_in_ast(
        &self,
        node: &AstNode,
        tainted_vars: &mut HashSet<String>,
        vulnerabilities: &mut Vec<TaintVulnerability>,
    ) {
        match &node.kind {
            // Variable assignment
            AstNodeKind::VariableDeclaration { name, .. } => {
                // Check if initializer is tainted
                if self.is_initializer_tainted(node, tainted_vars) {
                    tainted_vars.insert(name.clone());
                }
            }

            // Function call
            AstNodeKind::CallExpression { callee, .. } => {
                // Check if this is a sink with tainted data
                if self.is_sink_function(callee) {
                    // Check if any arguments are tainted
                    if self.has_tainted_arguments(node, tainted_vars) {
                        // Create vulnerability
                        if let Some(sink) = self.find_sink_by_name(callee) {
                            vulnerabilities.push(TaintVulnerability {
                                sink: sink.clone(),
                                tainted_value: TaintValue::new(
                                    callee.clone(),
                                    TaintSourceKind::UserInput,
                                ),
                                severity: Severity::High,
                            });
                        }
                    }
                }

                // Check if this call generates taint
                if let Some(summary) = self.summaries.get(callee) {
                    if summary.generates_taint || summary.returns_taint {
                        // Mark result as tainted
                        // In a real implementation, we'd track the result variable
                        tainted_vars.insert(format!("{}()", callee));
                    }
                }
            }

            AstNodeKind::FunctionDeclaration { .. } | AstNodeKind::MethodDeclaration { .. } => {
                // Enter new scope - analyze function body with fresh taint set
                let mut local_tainted = HashSet::new();
                for child in &node.children {
                    self.track_taint_in_ast(child, &mut local_tainted, vulnerabilities);
                }
                return; // Don't propagate local taint to parent scope
            }

            _ => {}
        }

        // Recursively process children
        for child in &node.children {
            self.track_taint_in_ast(child, tainted_vars, vulnerabilities);
        }
    }

    /// Check if initializer expression is tainted
    fn is_initializer_tainted(&self, node: &AstNode, tainted_vars: &HashSet<String>) -> bool {
        // Check children for tainted references or source calls
        for child in &node.children {
            if let AstNodeKind::CallExpression { callee, .. } = &child.kind {
                if self.is_source_function(callee) {
                    return true;
                }
                if let Some(summary) = self.summaries.get(callee) {
                    if summary.generates_taint || summary.returns_taint {
                        return true;
                    }
                }
            }

            if let AstNodeKind::Identifier { name } = &child.kind {
                if tainted_vars.contains(name) {
                    return true;
                }
            }

            // Recursively check
            if self.is_node_tainted(child, tainted_vars) {
                return true;
            }
        }

        false
    }

    /// Check if a node contains tainted data
    fn is_node_tainted(&self, node: &AstNode, tainted_vars: &HashSet<String>) -> bool {
        match &node.kind {
            AstNodeKind::Identifier { name } => tainted_vars.contains(name),
            AstNodeKind::CallExpression { callee, .. } => {
                if self.is_source_function(callee) {
                    return true;
                }
                if let Some(summary) = self.summaries.get(callee) {
                    if summary.generates_taint || summary.returns_taint {
                        return true;
                    }
                }
                false
            }
            _ => {
                // Check children
                node.children.iter().any(|c| self.is_node_tainted(c, tainted_vars))
            }
        }
    }

    /// Check if function call has tainted arguments
    fn has_tainted_arguments(&self, node: &AstNode, tainted_vars: &HashSet<String>) -> bool {
        for child in &node.children {
            if self.is_node_tainted(child, tainted_vars) {
                return true;
            }
        }
        false
    }

    // Helper methods

    fn find_function_node<'a>(&self, ast: &'a AstNode, func_name: &str) -> Option<&'a AstNode> {
        match &ast.kind {
            AstNodeKind::FunctionDeclaration { name, .. } if name == func_name => {
                return Some(ast);
            }
            AstNodeKind::MethodDeclaration { name, .. } => {
                // Handle both "ClassName.methodName" and just "methodName"
                if func_name.ends_with(&format!(".{}", name)) || name == func_name {
                    return Some(ast);
                }
            }
            _ => {}
        }

        for child in &ast.children {
            if let Some(found) = self.find_function_node(child, func_name) {
                return Some(found);
            }
        }

        None
    }

    fn extract_parameters(&self, func: &AstNode) -> Vec<String> {
        match &func.kind {
            AstNodeKind::FunctionDeclaration { parameters, .. } => {
                parameters.iter().map(|p| p.name.clone()).collect()
            }
            AstNodeKind::MethodDeclaration { parameters, .. } => {
                parameters.iter().map(|p| p.name.clone()).collect()
            }
            _ => vec![],
        }
    }

    fn extract_identifier(&self, node: &AstNode) -> Option<String> {
        match &node.kind {
            AstNodeKind::Identifier { name } => Some(name.clone()),
            _ => {
                for child in &node.children {
                    if let Some(id) = self.extract_identifier(child) {
                        return Some(id);
                    }
                }
                None
            }
        }
    }

    fn is_source_function(&self, name: &str) -> bool {
        let name_lower = name.to_lowercase();
        self.sources.iter().any(|s| {
            let source_lower = s.name.to_lowercase();
            name_lower.contains(&source_lower) || source_lower.contains(&name_lower)
        })
    }

    fn is_sink_function(&self, name: &str) -> bool {
        let name_lower = name.to_lowercase();
        self.sinks.iter().any(|s| {
            let sink_lower = s.name.to_lowercase();
            name_lower.contains(&sink_lower) || sink_lower.contains(&name_lower)
        })
    }

    fn is_sanitizer_function(&self, name: &str) -> bool {
        let name_lower = name.to_lowercase();
        self.sanitizers.iter().any(|s| {
            let sanitizer_lower = s.to_lowercase();
            name_lower.contains(&sanitizer_lower)
        })
    }

    fn find_sink_by_name(&self, name: &str) -> Option<&TaintSink> {
        let name_lower = name.to_lowercase();
        self.sinks.iter().find(|s| {
            let sink_lower = s.name.to_lowercase();
            name_lower.contains(&sink_lower) || sink_lower.contains(&name_lower)
        })
    }

    /// Configure default sources
    pub fn with_default_sources(mut self) -> Self {
        let user_input_sources = vec![
            "request.body", "request.query", "request.params",
            "req.body", "req.query", "req.params",
            "getUserInput", "getInput", "readInput",
            "input", "stdin", "argv", "os.Args",
        ];

        for source_name in user_input_sources {
            self.sources.push(TaintSource {
                name: source_name.to_string(),
                kind: TaintSourceKind::UserInput,
                node_id: 0,
            });
        }

        self
    }

    /// Configure default sinks
    pub fn with_default_sinks(mut self) -> Self {
        let sql_sinks = vec!["execute", "query", "exec", "raw", "prepare", "executeQuery"];
        for sink_name in sql_sinks {
            self.sinks.push(TaintSink {
                name: sink_name.to_string(),
                kind: TaintSinkKind::SqlQuery,
                node_id: 0,
            });
        }

        let cmd_sinks = vec!["exec", "spawn", "system", "popen", "os.system"];
        for sink_name in cmd_sinks {
            self.sinks.push(TaintSink {
                name: sink_name.to_string(),
                kind: TaintSinkKind::CommandExecution,
                node_id: 0,
            });
        }

        self
    }

    /// Configure default sanitizers
    pub fn with_default_sanitizers(mut self) -> Self {
        let sanitizers = vec![
            "escape", "sanitize", "validate",
            "escapeHtml", "escapeSql", "clean", "filter",
        ];

        for sanitizer in sanitizers {
            self.sanitizers.insert(sanitizer.to_string());
        }

        self
    }
}

impl Default for InterproceduralTaintAnalysis {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use kodecd_parser::ast::{Location, Span};

    fn test_location() -> Location {
        Location {
            file_path: "test.rs".to_string(),
            span: Span {
                start_line: 1,
                start_column: 0,
                end_line: 1,
                end_column: 10,
                start_byte: 0,
                end_byte: 10,
            },
        }
    }

    #[test]
    fn test_function_summary_creation() {
        let summary = FunctionTaintSummary::new("test_func".to_string());
        assert_eq!(summary.name, "test_func");
        assert!(!summary.returns_taint);
        assert!(!summary.generates_taint);
    }

    #[test]
    fn test_source_detection() {
        let mut analysis = InterproceduralTaintAnalysis::new()
            .with_default_sources();

        assert!(analysis.is_source_function("getUserInput"));
        assert!(analysis.is_source_function("getInput"));
        assert!(!analysis.is_source_function("normalFunction"));
    }

    #[test]
    fn test_sink_detection() {
        let mut analysis = InterproceduralTaintAnalysis::new()
            .with_default_sinks();

        assert!(analysis.is_sink_function("executeQuery"));
        assert!(analysis.is_sink_function("query"));
        assert!(!analysis.is_sink_function("normalFunction"));
    }

    #[test]
    fn test_sanitizer_detection() {
        let mut analysis = InterproceduralTaintAnalysis::new()
            .with_default_sanitizers();

        assert!(analysis.is_sanitizer_function("sanitize"));
        assert!(analysis.is_sanitizer_function("escapeHtml"));
        assert!(!analysis.is_sanitizer_function("normalFunction"));
    }

    #[test]
    fn test_parameter_extraction() {
        let analysis = InterproceduralTaintAnalysis::new();

        let func = AstNode::new(
            1,
            AstNodeKind::FunctionDeclaration {
                name: "test".to_string(),
                parameters: vec![
                    kodecd_parser::Parameter {
                        name: "a".to_string(),
                        param_type: None,
                        default_value: None,
                        is_optional: false,
                        is_rest: false,
                    },
                    kodecd_parser::Parameter {
                        name: "b".to_string(),
                        param_type: None,
                        default_value: None,
                        is_optional: false,
                        is_rest: false,
                    },
                ],
                return_type: None,
                is_async: false,
                is_generator: false,
            },
            test_location(),
            "fn test(a, b) {}".to_string(),
        );

        let params = analysis.extract_parameters(&func);
        assert_eq!(params, vec!["a", "b"]);
    }
}
